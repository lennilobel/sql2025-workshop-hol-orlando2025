# Build the Event Hub Client

In this lab, you will build a C# console application that listens to change events emitted by your SQL Server 2025 database via Change Event Streaming (CES). This consumer application will receive those events through Azure Event Hubs, deserialize the payloads, and display key change details in the console.

## Create the Visual Studio Project

1. Open **Visual Studio 2022**.
2. Select **Create a new project**.
3. Choose **Console App (C#)** and click **Next**.
4. Name the project `CESClient`.
5. Click **Next**.
6. Click **Create**.

## Install NuGet Packages

In **Solution Explorer**:

1. Right-click on the `CESClient` project and choose **Manage NuGet Packages**.
2. Go to the **Browse** tab and install the following packages:

   * `Azure.Messaging.EventHubs.Processor`
   
     Required to connect to and receive messages from Event Hubs. Provides the event    processor client that manages partition assignment and checkpointing.
   
   * `Azure.Storage.Blobs`
   
     Needed to store checkpoints in Azure Blob Storage so processing can resume from  the   correct position.
   
   * `Microsoft.Extensions.Configuration.Json`
     
     Enables loading configuration settings from `appsettings.json`.

   * `Newtonsoft.Json`
     
     Supports deserializing JSON event data into `JObject` and `JArray` types.

## Add a Configuration File

1. Right-click the `CESClient` project and choose **Add** > **New Item**.
2. Name it `appsettings.json`.
3. Replace its content with the following:

```json
{
  "EventHub": {
    "HostName": "<namespace-name>.servicebus.windows.net",
    "Name": "ces-hub",
    "SasToken": "<sas-token>"
  },
  "BlobStorage": {
    "ConnectionString": "<storage-connection-string>",
    "ContainerName": "ces-checkpoint"
  }
}
```

Replace the `<namespace-name>`, `<sas-token>`, and `<storage-connection-string>` placeholders with the **Event Hub Namespace Name**, **Event Hub SAS Token**, and **Storage Connection String** values provided by your instructor.

This file must be present in the output directory when the application runs, so it can read the configuration settings. To ensure this, right-click the `appsettings.json` file and choose **Properties**. Then set **Copy to Output Directory** to **Copy if newer**.

## Add the Code

First, create the outer shell of the `Program.cs` file. This will contain the `Program` class and namespace that hosts all your methods. Double-click `Program.cs` in **Solution Explorer** and replace its content with the following:

```csharp
using Azure;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Consumer;
using Azure.Messaging.EventHubs.Processor;
using Azure.Storage.Blobs;
using Microsoft.Extensions.Configuration;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CESClient
{
  public class Program
  {
    private static int _eventCount;

    // Add each method below this point.

  }
}
```

We'll use `_eventCount` as a simple counter to keep track of how many events have been processed.

Now let's build the C# client step-by-step, method by method.

### Main Method

The `Main` method initializes and runs the CESClient console application. It starts by loading and displaying configuration settings from `appsettings.json`, including Event Hub connection details, and Blob Storage credentials used for checkpointing. It then waits for a key press to start listening for events.

Next, it creates a `BlobContainerClient` to manage checkpoints, and then initializes an `EventProcessorClient` using the Event Hub settings and the storage client.

Event handlers are then attached for processing incoming events and handling errors. The application signals it’s ready, resets the event counter, and starts processing with `StartProcessingAsync`. Finally, it waits for the next key press, then stops processing with `StopProcessingAsync`, ensuring a clean shutdown.

```csharp
public static async Task Main(string[] args)
{
  // Load configuration from appsettings.json
  var config = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
    .Build();

  var eventHubHostName = config["EventHub:HostName"];
  var eventHubName = config["EventHub:Name"];
  var eventHubSasToken = config["EventHub:SasToken"];

  var blobStorageConnectionString = config["BlobStorage:ConnectionString"];
  var blobStorageContainerName = config["BlobStorage:ContainerName"];

  // Say hello
  Console.WriteLine("SQL Server 2025 Change Event Streaming Client");
  Console.WriteLine();
  Console.WriteLine($"Event Hub Configuration");
  Console.WriteLine($"  Host name:         {eventHubHostName}");
  Console.WriteLine($"  Hub name:          {eventHubName}");
  Console.WriteLine($"  SAS token:         {eventHubSasToken.Substring(0, 80)}...");
  Console.WriteLine();
  Console.WriteLine($"Blob Storage Configuration");
  Console.WriteLine($"  Connection string: {blobStorageConnectionString}");
  Console.WriteLine($"  Container name:    {blobStorageContainerName}");
  Console.WriteLine();
  Console.WriteLine("Press any key to start.");
  Console.ReadKey(intercept: true);

  Console.WriteLine();
  Console.Write("Initializing... ");

  // Create a blob container client that the event processor will use for checkpointing
  var storageClient = new BlobContainerClient(blobStorageConnectionString, blobStorageContainerName);

  // Create an event processor client to process events in the event hub
  var processor = new EventProcessorClient(
    checkpointStore: storageClient,
    EventHubConsumerClient.DefaultConsumerGroupName,
    fullyQualifiedNamespace: eventHubHostName,
    eventHubName,
    credential: new AzureSasCredential(eventHubSasToken)
  );

  // Register handlers for processing events and errors
  processor.ProcessEventAsync += ProcessEventHandler;
  processor.ProcessErrorAsync += ProcessErrorHandler;

  // Start listening for events
  Console.Write("starting... ");
  _eventCount = 0;

  await processor.StartProcessingAsync();

  Console.WriteLine("started... press any key to stop.");
  Console.WriteLine();
  Console.ReadKey(intercept: true);

  // Stop listening for events
  await processor.StopProcessingAsync();

  Console.WriteLine("Stopped");
}
```

### ProcessEventHandler

The `ProcessEventHandler` method is called automatically each time a new event is received from the Event Hub:

```csharp
private static async Task ProcessEventHandler(ProcessEventArgs eventArgs)
{
  try
  {
    // Get the root JSON object from the event data body
    var eventDataBytes = eventArgs.Data.Body.ToArray();
    var eventDataJson = Encoding.UTF8.GetString(eventDataBytes);
    var eventData = JObject.Parse(eventDataJson);

    // Parse event data
    var operation = eventData["operation"].Value<string>();
    var dataJson = eventData["data"].Value<string>();
    var data = JObject.Parse(dataJson);
    var primaryKeyColumns = data["eventsource"]["pkkey"].ToObject<JArray>();
    var primaryKey = string.Join(", ", primaryKeyColumns.OfType<JObject>().Select(obj => $"{obj["columnname"]} = {obj["value"]}"));
    var columns = data["eventsource"]["cols"].ToObject<JArray>();
    var currentValues = JsonConvert.DeserializeObject<Dictionary<string, string>>(data["eventrow"]["current"].Value<string>());
    var previousValues = JsonConvert.DeserializeObject<Dictionary<string, string>>(data["eventrow"]["old"].Value<string>());

    // Process the event

    DisplayEventMetadata(eventArgs, eventData, data);

    switch (operation)
    {
      case "INS":
        ProcessInsert(primaryKey, columns, currentValues);
        break;
      case "UPD":
        ProcessUpdate(primaryKey, columns, currentValues, previousValues);
        break;
      case "DEL":
        ProcessDelete(primaryKey, columns, previousValues);
        break;
    }

    // Save the checkpoint (offset + sequence number) in blob storage
    await eventArgs.UpdateCheckpointAsync();
  }
  catch (Exception ex)
  {
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine(ex.Message);
    Console.ResetColor();
  }
}
```

The method receives a `ProcessEventArgs` object that contains the event data and metadata in a CloudEvent format, which looks like this:

```json
{
  "specversion": "1.0",
  "type": "com.microsoft.SQL.CES.DML.V1",
  "source": "\/",
  "id": "cc3fcdca-09c0-4f46-a8d3-5d0c3c1eb85a",
  "logicalid": "8376457a-17af-49f4-b9ea-0d5071f515f4:0000002C000007300011:00000000000000000002",
  "time": "2025-06-30T12:29:46.290Z",
  "datacontenttype": "application\/avro-json",
  "operation": "UPD",
  "segmentindex": 1,
  "finalsegment": true,
  "data": "{\n  \"eventsource\": {\n    \"db\": \"CesDemo\",\n    \"schema\": \"dbo\",\n    \"tbl\": \"Product\",\n    \"cols\": [\n      {\n        \"name\": \"ProductId\",\n        \"type\": \"int\",\n        \"index\": 0\n      },\n      {\n        \"name\": \"ItemsInStock\",\n        \"type\": \"smallint\",\n        \"index\": 5\n      }\n    ],\n    \"pkkey\": [\n      {\n        \"columnname\": \"ProductId\",\n        \"value\": \"2\"\n      }\n    ],\n    \"transaction\": {\n      \"commitlsn\": \"0000002C:00000730:0011\",\n      \"beginlsn\": \"0000002C:00000730:000C\",\n      \"sequencenumber\": 2,\n      \"committime\": \"2025-06-30T12:29:46.290Z\"\n    }\n  },\n  \"eventrow\": {\n    \"old\": \"{\\\"ProductId\\\": \\\"2\\\", \\\"ItemsInStock\\\": \\\"8\\\"}\",\n    \"current\": \"{\\\"ProductId\\\": \\\"2\\\", \\\"ItemsInStock\\\": \\\"7\\\"}\"\n  }\n}"
}
```

The outer JSON contains several properties, notably `operation` and `data`. The `operation` type describes the DML operation for the event (`INS`, `UPD`, or `DEL`). The `data` property holds a nested serialized JSON string representing the actual change event payload. Here is an example of the inner `data` JSON after deserialization:

```json
{
  "eventsource": {
    "db": "CesDemo",
    "schema": "dbo",
    "tbl": "Product",
    "cols": [
      {
        "name": "ProductId",
        "type": "int",
        "index": 0
      },
      {
        "name": "ItemsInStock",
        "type": "smallint",
        "index": 5
      }
    ],
    "pkkey": [
      {
        "columnname": "ProductId",
        "value": "2"
      }
    ],
    "transaction": {
      "commitlsn": "0000002C:00000730:0011",
      "beginlsn": "0000002C:00000730:000C",
      "sequencenumber": 2,
      "committime": "2025-06-30T12:29:46.290Z"
    }
  },
  "eventrow": {
    "old": "{\"ProductId\": \"2\", \"ItemsInStock\": \"8\"}",
    "current\": "{\"ProductId\": \"2\", \"ItemsInStock\": \"7\"}"
  }
}
```

The `ProcessEventHandler` method deserializes this JSON to access the underlying data, which includes primary key information, column information, as well current and (if so configured) previous values.

Before processing the event data, it calls `DisplayEventMetadata` to display key event details for context. It then processes the `operation` type (`INS`, `UPD`, or `DEL`) by calling the appropriate method (`ProcessInsert`, `ProcessUpdate`, or `ProcessDelete`).

After processing, it invokes `eventArgs.UpdateCheckpointAsync()`. This updates the checkpoint to record that this event has been handled, ensuring no duplicates on restart. Any exceptions are caught and logged in red to make them easily visible in the console.

### DisplayEventMetadata

The `DisplayEventMetadata` method displays detailed information about each change event. It first shows basic metadata from the `ProcessEventArgs` object, including the event's sequence number and offset within the partition.

Next, it extracts and displays key CloudEvent fields from the outer JSON, such as the event’s operation type, timestamp, unique ID, logical ID, and content type. This helps contextualize the event’s origin and structure.

Finally, it dives into the inner event payload to display the database, schema, and table where the change occurred. This metadata gives the user a clear understanding of the event’s context before the row-level data is processed and displayed.

```csharp
private static void DisplayEventMetadata(ProcessEventArgs eventArgs, JObject root, JObject data)
{
  Console.ForegroundColor = ConsoleColor.White;
  Console.WriteLine();
  Console.WriteLine($"╔══════════════════════╗");
  Console.WriteLine($"║ Processing event {++_eventCount,-3} ║");
  Console.WriteLine($"╚══════════════════════╝");
  Console.WriteLine();
  Console.ResetColor();
  Console.WriteLine("Event Args");
  Console.WriteLine($"  Sequence            {eventArgs.Data.SequenceNumber}");
  Console.WriteLine($"  Offset              {eventArgs.Data.OffsetString}");
  Console.WriteLine();
  Console.WriteLine("Event Data");
  Console.WriteLine($"  Operation           {root["operation"]}");
  Console.WriteLine($"  Time                {root["time"]}");
  Console.WriteLine($"  Event ID            {root["id"]}");
  Console.WriteLine($"  Logical ID          {root["logicalid"]}");
  Console.WriteLine($"  Data content type   {root["datacontenttype"]}");
  Console.WriteLine();
  Console.WriteLine("Data");
  Console.WriteLine($"  Database            {data["eventsource"]["db"]}");
  Console.WriteLine($"  Schema              {data["eventsource"]["schema"]}");
  Console.WriteLine($"  Table               {data["eventsource"]["tbl"]}");
  Console.WriteLine();
}
```

### ProcessInsert

The `ProcessInsert` method handles events for new rows inserted into a table.

This method first labels the operation as an insert, and displays the new row's primary key. It then loops through the column metadata and, for each column, retrieves its name and displays the corresponding value from the `current` dictionary—representing the newly inserted row. This makes it easy to see exactly which values were added.

```csharp
private static void ProcessInsert(string primaryKey, JArray columns, Dictionary<string, string> current)
{
  Console.ForegroundColor = ConsoleColor.Green;
  Console.WriteLine($"Insert");
  Console.WriteLine($"  {"Primary Key",-20}{primaryKey}");

  foreach (var column in columns)
  {
    var columnName = column["name"].Value<string>();
    Console.WriteLine($"  {columnName,-20}{current[columnName]}");
  }

  Console.ResetColor();
}
```

### ProcessUpdate

The `ProcessUpdate` method handles row update events. It begins by labeling the operation as an update, and displays the updated row's primary key. It then iterates through the list of columns to show current and (if so configured) previous values.

```csharp
private static void ProcessUpdate(string primaryKey, JArray columns, Dictionary<string, string> currentValues, Dictionary<string, string> previousValues)
{
  Console.ForegroundColor = ConsoleColor.Yellow;
  Console.WriteLine($"Update");
  Console.WriteLine($"  {"Primary Key",-20}{primaryKey}");

  foreach (var column in columns)
  {
    var columnName = column["name"].Value<string>();

    if (previousValues.Count == 0)
    {
      Console.WriteLine($"  {columnName,-20}{currentValues[columnName]}");
    }
    else if (currentValues[columnName] != previousValues[columnName])
    {
      Console.WriteLine($"  {columnName,-20}{currentValues[columnName]} (current)");
      Console.ForegroundColor = ConsoleColor.DarkYellow;
      Console.WriteLine($"  {columnName,-20}{previousValues[columnName]} (previous)");
      Console.ForegroundColor = ConsoleColor.Yellow;
    }
  }

  Console.ResetColor();
}
```

### ProcessDelete

The `ProcessDelete` method handles events where a row has been deleted from the database.

It begins by labeling the operation as a delete, and displays the deleted row's primary key. It loops through the column metadata and prints the values of each column, which represents the state of the row before it was removed. This provides a clear view of the data that was deleted.

```csharp
private static void ProcessDelete(string primaryKey, JArray columns, Dictionary<string, string> previous)
{
  Console.ForegroundColor = ConsoleColor.Red;
  Console.WriteLine($"Delete");
  Console.WriteLine($"  {"Primary Key",-20}{primaryKey}");

  foreach (var column in columns)
  {
    var columnName = column["name"].Value<string>();
    Console.WriteLine($"  {columnName,-20}{previous[columnName]}");
  }

  Console.ResetColor();
}
```

### ProcessErrorHandler

The `ProcessErrorHandler` method is invoked whenever an error occurs during event processing or checkpointing. It displays the exception message in red to make it stand out in the console.

After logging the error, it returns a completed task to satisfy the async event handler signature without interrupting the processor's execution.

```csharp
private static Task ProcessErrorHandler(ProcessErrorEventArgs e)
{
  Console.ForegroundColor = ConsoleColor.Red;
  Console.WriteLine(e.Exception.Message);
  Console.ResetColor();
  return Task.CompletedTask;
}
```

Your console application is now ready to receive change events.

## Run the Application

1. In **Visual Studio**, press `F5` or click the **Debug** menu and choose **Start Debugging**.
2. A console window will appear.

You should see the configuration information displayed by the `main` method, followed by a prompt to `Press any key to start`. Now press any key to start listening for events. The console should update to show:

`Initializing... starting... waiting... press any key to stop.`

This indicates your application is successfully connected to the Event Hub and listening for change events.

If you see any errors, double-check your configuration settings and ensure all required NuGet packages are installed.

Now that your client is up and running, you will test it by generating change events in the database.

___

▶ [Lab: Generate Change Events](https://github.com/lennilobel/sql2025-workshop-hol-orlando2025/blob/main/HOL/3.%20Change%20Event%20Streaming/4.%20Generate%20Change%20Events.md)
