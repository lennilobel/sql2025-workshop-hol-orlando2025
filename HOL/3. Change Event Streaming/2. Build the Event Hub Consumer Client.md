# Build the Event Hub Consumer Client

In this lab, you will build a C# console application that listens to change events emitted by your SQL Server 2025 database via Change Event Streaming (CES). This consumer application will receive those events through Azure Event Hubs, deserialize the payloads, and display key change details in the console.

> Recall that each attendee will use a **unique consumer group** (e.g., `cg-john-smith`, or `cg-jane-doe`, etc.) to isolate their checkpoints in the Azure Blob Storage container shared by all attendees..

## Create the Visual Studio Project

1. Open **Visual Studio 2022**.
2. Select **Create a new project**.
3. Choose **Console App (C#)**.
4. Name the project `CESClient`.
5. Click **Next**.
6. Click **Create**.

## Install NuGet Packages

In **Solution Explorer**:

1. Right-click on the `CESClient` project and choose **Manage NuGet Packages**.
2. Go to the **Browse** tab and install the following packages:

* `Azure.Messaging.EventHubs`: Required to connect to and receive messages from Event Hubs.
* `Azure.Messaging.EventHubs.Processor`: Provides the event processor client that manages partition assignment and checkpointing.
* `Azure.Storage.Blobs`: Needed to store checkpoints in Azure Blob Storage so processing can resume from the correct position.
* `Microsoft.Extensions.Configuration`: Enables loading configuration settings from files or environment variables.
* `Microsoft.Extensions.Configuration.Json`: Adds support for reading configuration settings from `appsettings.json`.

These libraries work together to make the client robust and flexible.

## Add a Configuration File

1. Right-click the project and choose **Add** > **New Item**.
2. Name it `appsettings.json`.
3. Replace its content with the following:

```json
{
  "DatabaseName": "CesDemo_firstname_lastname",
  "EventHub": {
    "HostName": "sql2025-ces.servicebus.windows.net",
    "Name": "ces-hub",
    "SasToken": "provided by the instructor",
    "ConsumerGroup": "cg-firstname-lastname"
  },
  "BlobStorage": {
    "ConnectionString": "provided by the instructor",
    "ContainerName": "ces-checkpoint"
  }
}
```

Replace the values for `DatabaseName` and `ConsumerGroup` your own student-specific database name and event hub consumer group name respeectively. Also replace the values for `SasToken` and `ConnectionString` with the SAS token and Azure Blob Storage connection string provided by the instructor.

> **Note:** Make sure the database name matches with the name you used to create the database in the previous lab, using underscore `_` characters as delimiters. Similarly, make sure that the consumer group name matches the one supplied to you by the instructor, which uses hyphen `-` characters as delimiters.

This file must be present in the output directory when the application runs, so it can read the configuration settings. To ensure this, right-click the `appsettings.json` file and choose **Properties**. Then set **Copy to Output Directory** to **Copy if newer**.

## Add the Main Program Code

Before adding methods, create the outer shell of the `Program.cs` file. This will contain the `Program` class and namespace that hosts all your methods:

[GPT: Explain the private static strings]

```csharp
using Azure;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Processor;
using Azure.Storage.Blobs;
using Microsoft.Extensions.Configuration;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Threading.Tasks;

namespace CESClient
{
  public class Program
  {
    private static string _databaseName;
    private static int _eventCount;

    // Add each method below this point.

  }
}
```

Now we will build the C# client step-by-step, method by method.

## Main Method

[GPT: Explain the below method in detail]

```csharp
public static async Task Main(string[] args)
{
  Console.WriteLine("SQL Server 2025 Change Event Streaming Client");
  Console.WriteLine();
  Console.Write("Initializing... ");

  var config = new ConfigurationBuilder()
      .SetBasePath(Directory.GetCurrentDirectory())
      .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
      .Build();

  _databaseName = config["DatabaseName"];

  var blobStorageConnectionString = config["BlobStorage:ConnectionString"];
  var blobStorageContainerName = config["BlobStorage:ContainerName"];

  var storageClient = new BlobContainerClient(blobStorageConnectionString, blobStorageContainerName);

  var eventHubHostName = config["EventHub:HostName"];
  var eventHubName = config["EventHub:Name"];
  var sasToken = config["EventHub:SasToken"];
  var consumerGroup = config["EventHub:ConsumerGroup"];

  var processor = new EventProcessorClient(
      checkpointStore: storageClient,
      consumerGroup,
      fullyQualifiedNamespace: eventHubHostName,
      eventHubName,
      credential: new AzureSasCredential(sasToken)
  );

  processor.ProcessEventAsync += ProcessEventHandler;
  processor.ProcessErrorAsync += ProcessErrorHandler;

  Console.Write("starting... ");
  _eventCount = 0;

  await processor.StartProcessingAsync();

  Console.WriteLine("waiting... press any key to stop.");
  Console.ReadKey(intercept: true);

  await processor.StopProcessingAsync();
  Console.WriteLine("Stopped");
}
```

## ProcessEventHandler

[GPT: Explain the below method in detail]

```csharp
private static async Task ProcessEventHandler(ProcessEventArgs eventArgs)
{
  try
  {
    using var doc = JsonDocument.Parse(eventArgs.Data.Body.ToArray());
    var root = doc.RootElement;
    var dataJson = root.GetProperty("data");

    using var innerDoc = JsonDocument.Parse(dataJson.GetString());
    var data = innerDoc.RootElement;

    var db = data.GetProperty("eventsource").GetProperty("db").GetString();
    if (db != _databaseName)
    {
      Console.WriteLine($"(skipping event received from a different database [{db}])");
      return;
    }

    Console.WriteLine($"Processing event... #{++_eventCount}");

    var operation = root.GetProperty("operation").GetString();
    var cols = data.GetProperty("eventsource").GetProperty("cols").EnumerateArray();
    var current = JsonSerializer.Deserialize<Dictionary<string, string>>(data.GetProperty("eventrow").GetProperty("current").GetString());
    var old = JsonSerializer.Deserialize<Dictionary<string, string>>(data.GetProperty("eventrow").GetProperty("old").GetString());

    DisplayEventMetadata(eventArgs, root, data);

    switch (operation)
    {
      case "INS":
        ProcessInsert(cols, current);
        break;
      case "UPD":
        ProcessUpdate(cols, current, old);
        break;
      case "DEL":
        ProcessDelete(cols, old);
        break;
    }

    Console.WriteLine();
    Console.WriteLine(new string('-', 80));
    Console.WriteLine();

    await eventArgs.UpdateCheckpointAsync();
  }
  catch (Exception ex)
  {
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine(ex.Message);
    Console.ResetColor();
  }
}

```

## DisplayEventMetadata

[GPT: Explain the below method in detail]

```csharp
private static void DisplayEventMetadata(ProcessEventArgs eventArgs, JsonElement root, JsonElement data)
{
  Console.WriteLine("Event Args");
  Console.WriteLine($"  Sequence:Offset => {eventArgs.Data.SequenceNumber}:{eventArgs.Data.Offset}");
  Console.WriteLine();
  Console.WriteLine("Event Data");
  Console.WriteLine($"  Spec version:       {root.GetProperty("specversion").GetString()}");
  Console.WriteLine($"  Operation:          {root.GetProperty("type").GetString()}");
  Console.WriteLine($"  Time:               {root.GetProperty("time").GetString()}");
  Console.WriteLine($"  Event ID:           {root.GetProperty("id").GetString()}");
  Console.WriteLine($"  Logical ID:         {root.GetProperty("logicalid").GetString()}");
  Console.WriteLine($"  Operation:          {root.GetProperty("operation").GetString()}");
  Console.WriteLine($"  Data content type:  {root.GetProperty("datacontenttype").GetString()}");
  Console.WriteLine();
  Console.WriteLine("Data");
  Console.WriteLine($"  Database:           {data.GetProperty("eventsource").GetProperty("db").GetString()}");
  Console.WriteLine($"  Schema:             {data.GetProperty("eventsource").GetProperty("schema").GetString()}");
  Console.WriteLine($"  Table:              {data.GetProperty("eventsource").GetProperty("tbl").GetString()}");
  Console.WriteLine();
}
```

## ProcessInsert

[GPT: Explain the below method in detail]

```csharp
private static void ProcessInsert(JsonElement.ArrayEnumerator cols, Dictionary<string, string> current)
{
  Console.WriteLine("Operation: Insert");
  Console.ForegroundColor = ConsoleColor.Green;

  foreach (var col in cols)
  {
    var name = col.GetProperty("name").GetString();
    Console.WriteLine($"\t{name}: {current[name]}");
  }

  Console.ResetColor();
}
```

### ProcessUpdate

[GPT: Explain the below method in detail]

```csharp
private static void ProcessUpdate(JsonElement.ArrayEnumerator cols, Dictionary<string, string> current, Dictionary<string, string> old)
{
  Console.WriteLine("Operation: Update");

  foreach (var col in cols)
  {
    var name = col.GetProperty("name").GetString();

    if (old.Count > 0 && current[name] != old[name])
    {
      Console.ForegroundColor = ConsoleColor.Yellow;
      Console.WriteLine($"\t{name}: {current[name]} (old: {old[name]})");
      Console.ResetColor();
    }
    else
    {
      Console.WriteLine($"\t{name}: {current[name]}");
    }
  }
}
```

### ProcessDelete

[GPT: Explain the below method in detail]

```csharp
private static void ProcessDelete(JsonElement.ArrayEnumerator cols, Dictionary<string, string> old)
{
  Console.WriteLine("Operation: Delete");
  Console.ForegroundColor = ConsoleColor.Red;

  foreach (var col in cols)
  {
    var name = col.GetProperty("name").GetString();
    Console.WriteLine($"\t{name}: {old[name]}");
  }

  Console.ResetColor();
}
```

## ProcessErrorHandler

[GPT: Explain the below method in detail]

```csharp
private static Task ProcessErrorHandler(ProcessErrorEventArgs e)
{
  Console.ForegroundColor = ConsoleColor.Red;
  Console.WriteLine(e.Exception.Message);
  Console.ResetColor();
  return Task.CompletedTask;
}
```

Your console application is now ready to receive change events.

### Run the Application to Verify Setup

1. In **Visual Studio**, press `F5` or click **Start Debugging**.
2. A console window will appear.

You should see output like this:

```
SQL Server 2025 Change Event Streaming Client

Initializing... starting... waiting... press any key to stop.
```

This indicates your application is successfully connected to the Event Hub and listening for change events.

If you see any errors, double-check your configuration settings and ensure all required NuGet packages are installed.
