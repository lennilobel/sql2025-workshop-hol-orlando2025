# Build the Event Hub Consumer Client

In this lab, you will build a C# console application that listens to change events emitted by your SQL Server 2025 database via Change Event Streaming (CES). This consumer application will receive those events through Azure Event Hubs, deserialize the payloads, and display key change details in the console.

> ✅ Each student must use a **unique consumer group** (e.g., `student1`, `student2`, etc.) to isolate their view of the event stream. This is important because the Event Hub is shared across all students.

---

### Create the Visual Studio Project

1. Open **Visual Studio 2022** or later.
2. Select **Create a new project**.
3. Choose **Console App (.NET Core)** or **Console App (.NET 6/7/8)** depending on your installed SDK.
4. Name the project `CESClient` and choose a location.
5. Click **Create**.

### Install NuGet Packages

In **Solution Explorer**:

1. Right-click on the `CESClient` project and choose **Manage NuGet Packages**.
2. Go to the **Browse** tab and install the following packages:

* `Azure.Messaging.EventHubs`: Required to connect to and receive messages from Event Hubs.
* `Azure.Messaging.EventHubs.Processor`: Provides the event processor client that manages partition assignment and checkpointing.
* `Azure.Storage.Blobs`: Needed to store checkpoints in Azure Blob Storage so processing can resume from the correct position.
* `Microsoft.Extensions.Configuration`: Enables loading settings from files or environment variables.
* `Microsoft.Extensions.Configuration.Json`: Adds support for reading settings from `appsettings.json`.

These libraries work together to make the client robust and flexible.

### Add Configuration File

1. Right-click the project → **Add** → **New Item** → Select **JSON File**.
2. Name it `appsettings.json`.
3. Replace its content with the following, inserting your own student-specific consumer group name:

```json
{
  "EventHub": {
    "HostName": "sql2025-ces.servicebus.windows.net",
    "Name": "ces-hub",
    "SasToken": "<provided by instructor>",
    "ConsumerGroup": "student-unique-group"
  },
  "BlobStorage": {
    "ConnectionString": "<provided by instructor>",
    "ContainerName": "ces-blob"
  }
}
```

Right-click the `appsettings.json` file → **Properties** → Set **Copy to Output Directory** to **Copy if newer**.

### Add the Main Program Code

Before adding methods, create the outer shell of the `Program.cs` file. This will contain the `Program` class and namespace that hosts all your methods:

```csharp
using Azure;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Consumer;
using Azure.Messaging.EventHubs.Processor;
using Azure.Storage.Blobs;
using Microsoft.Extensions.Configuration;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Threading.Tasks;

namespace CESClient
{
    public class Program
    {
        private static int _eventCount;

        // Add each method below this point.
    }
}
```

Now we will build the C# client step-by-step, method by method.

We will now build the C# client step-by-step, method by method.

#### Main Method

This is the program entry point. It loads configuration, creates the `EventProcessorClient`, starts listening for events, and stops when the user presses a key.

```csharp
public static async Task Main(string[] args)
{
    Console.WriteLine("SQL Server 2025 Change Event Streaming Client");
    Console.WriteLine();
    Console.Write("Initializing... ");

    var config = new ConfigurationBuilder()
        .SetBasePath(Directory.GetCurrentDirectory())
        .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
        .Build();

    var blobStorageConnectionString = config["BlobStorage:ConnectionString"];
    var blobStorageContainerName = config["BlobStorage:ContainerName"];
    var storageClient = new BlobContainerClient(blobStorageConnectionString, blobStorageContainerName);

    var eventHubHostName = config["EventHub:HostName"];
    var eventHubName = config["EventHub:Name"];
    var sasToken = config["EventHub:SasToken"];
    var consumerGroup = config["EventHub:ConsumerGroup"];

    var processor = new EventProcessorClient(
        checkpointStore: storageClient,
        consumerGroup: consumerGroup,
        fullyQualifiedNamespace: eventHubHostName,
        eventHubName,
        credential: new AzureSasCredential(sasToken)
    );

    processor.ProcessEventAsync += ProcessEventHandler;
    processor.ProcessErrorAsync += ProcessErrorHandler;

    Console.Write("starting... ");
    _eventCount = 0;

    await processor.StartProcessingAsync();

    Console.WriteLine("waiting... press any key to stop.");
    Console.ReadKey(intercept: true);

    await processor.StopProcessingAsync();
    Console.WriteLine("Stopped");
}
```

#### ProcessEventHandler

This method is triggered for each event received. It parses the message and delegates to an appropriate handler based on the operation type.

```csharp
private static async Task ProcessEventHandler(ProcessEventArgs eventArgs)
{
    Console.WriteLine($"Processing event... #{++_eventCount}");

    try
    {
        var eventData = JsonSerializer.Deserialize<EventData>(eventArgs.Data.Body.ToArray());
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        var data = JsonSerializer.Deserialize<Data>(eventData.data, options);
        var current = JsonSerializer.Deserialize<Dictionary<string, string>>(data.eventrow.current, options);
        var old = JsonSerializer.Deserialize<Dictionary<string, string>>(data.eventrow.old, options);

        DisplayEventMetadata(eventArgs, eventData, data);

        switch (eventData.operation)
        {
            case "INS": ProcessInsert(data, current); break;
            case "UPD": ProcessUpdate(data, current, old); break;
            case "DEL": ProcessDelete(data, old); break;
        }

        Console.WriteLine();
        Console.WriteLine(new string('-', 80));
        Console.WriteLine();

        await eventArgs.UpdateCheckpointAsync();
    }
    catch (Exception ex)
    {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine(ex.Message);
        Console.ResetColor();
    }
}
```

#### DisplayEventMetadata

Displays high-level metadata and context about the event.

```csharp
private static void DisplayEventMetadata(ProcessEventArgs eventArgs, EventData eventData, Data data)
{
    Console.WriteLine("Event Args");
    Console.WriteLine($"  Sequence:Offset => {eventArgs.Data.SequenceNumber}:{eventArgs.Data.Offset}");
    Console.WriteLine();
    Console.WriteLine("Event Data");
    Console.WriteLine($"  Spec version:       {eventData.specversion}");
    Console.WriteLine($"  Operation:          {eventData.type}");
    Console.WriteLine($"  Time:               {eventData.time}");
    Console.WriteLine($"  Event ID:           {eventData.id}");
    Console.WriteLine($"  Logical ID:         {eventData.logicalid}");
    Console.WriteLine($"  Operation:          {eventData.operation}");
    Console.WriteLine($"  Data content type:  {eventData.datacontenttype}");
    Console.WriteLine();
    Console.WriteLine("Data");
    Console.WriteLine($"  Database:           {data.eventsource.db}");
    Console.WriteLine($"  Schema:             {data.eventsource.schema}");
    Console.WriteLine($"  Table:              {data.eventsource.tbl}");
    Console.WriteLine();
}
```

#### ProcessInsert

Displays values for inserted rows using green text.

```csharp
private static void ProcessInsert(Data data, Dictionary<string, string> current)
{
    Console.WriteLine("Operation: Insert");
    Console.ForegroundColor = ConsoleColor.Green;

    foreach (var item in data.eventsource.cols)
        Console.WriteLine($"	{item.name}: {current[item.name]}");

    Console.ResetColor();
}
```

#### ProcessUpdate

Displays current and (if available) old values for updated rows. Highlights changes in yellow.

```csharp
private static void ProcessUpdate(Data data, Dictionary<string, string> current, Dictionary<string, string> old)
{
    Console.WriteLine("Operation: Update");

    foreach (var item in data.eventsource.cols)
    {
        if (old.Count > 0 && current[item.name] != old[item.name])
        {
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine($"	{item.name}: {current[item.name]} (old: {old[item.name]})");
            Console.ResetColor();
        }
        else
        {
            Console.WriteLine($"	{item.name}: {current[item.name]}");
        }
    }
}
```

#### ProcessDelete

Displays deleted row values in red.

```csharp
private static void ProcessDelete(Data data, Dictionary<string, string> old)
{
    Console.WriteLine("Operation: Delete");
    Console.ForegroundColor = ConsoleColor.Red;

    foreach (var item in data.eventsource.cols)
        Console.WriteLine($"	{item.name}: {old[item.name]}");

    Console.ResetColor();
}
```

#### ProcessErrorHandler

Handles unexpected errors encountered during processing.

```csharp
private static Task ProcessErrorHandler(ProcessErrorEventArgs e)
{
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine(e.Exception.Message);
    Console.ResetColor();
    return Task.CompletedTask;
}
```

### Add Supporting Classes

Add a new class file named `EventModels.cs` and paste the following:

```csharp
using System.Collections.Generic;

namespace CESClient
{
    public class EventData
    {
        public string specversion { get; set; }
        public string type { get; set; }
        public string source { get; set; }
        public string id { get; set; }
        public string logicalid { get; set; }
        public string time { get; set; }
        public string datacontenttype { get; set; }
        public string operation { get; set; }
        public int splitindex { get; set; }
        public int splittotalcnt { get; set; }
        public string data { get; set; }
    }

    public class Data
    {
        public Eventsource eventsource { get; set; }
        public Eventrow eventrow { get; set; }
    }

    public class Eventsource
    {
        public string db { get; set; }
        public string schema { get; set; }
        public string tbl { get; set; }
        public List<Col> cols { get; set; }
        public List<object> pkkey { get; set; }
    }

    public class Col
    {
        public string name { get; set; }
        public string type { get; set; }
        public int index { get; set; }
    }

    public class Eventrow
    {
        public string old { get; set; }
        public string current { get; set; }
    }
}
```

Once complete, your console application is ready to receive change events.

### Run the Application to Verify Setup

1. In **Visual Studio**, press `F5` or click **Start Debugging**.
2. A console window will appear.

You should see output like this:

```
SQL Server 2025 Change Event Streaming Client

Initializing... starting... waiting... press any key to stop.
```

✅ This indicates your application is successfully connected to the Event Hub and listening for change events.

If you see any errors, double-check your configuration settings and ensure all required NuGet packages are installed.

Continue with **Lab 3** to trigger and observe event activity from SQL Server.
