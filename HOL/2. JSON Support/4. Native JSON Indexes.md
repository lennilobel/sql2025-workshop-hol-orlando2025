# Native JSON Indexes

To enable fast filtering, SQL Server 2025 introduces native JSON indexing. Instead of creating and indexing computed columns, you can declare a JSON index directly on property paths.

This provides an alternative to the legacy approach used in earlier versions of SQL Server. Previously, developers would create **computed columns** based on `JSON_VALUE()` expressions and then index those columns. While effective, this method required more schema scaffolding and introduced some maintenance overhead. It also persisted the computed values, which would consume additional storage.

In contrast, `CREATE JSON INDEX` in SQL Server 2025 allows you to define **JSON path indexes directly** against native `json` columns. SQL Server transparently builds and maintains a specialized index structure behind the scenes, with full awareness of the JSON document structure. These indexes are more efficient, easier to maintain, and allow more expressive querying without schema bloat.

## Indexing JSON Properties with Computed Columns (Legacy Pattern)

First, let's review what is now referred to as the legacy pattern (computed column + B‑tree index). Although the new JSON indexes are preferred, this method remains valid and can still be useful in certain scenarios, especially when dealing with fixed, flat JSON paths and when targeting compatibility with SQL Server versions prior to 2025.

For example, if we are frequently querying the basket status of our customers, then we will certainly want to index the `$.basket.status` property to improve performance. The following snippet shows how to do this using the legacy approach. Simply create a computed column that extracts the desired property using `JSON_VALUE()`, then create a standard index on that computed column:

```sql
ALTER TABLE Customer 
 ADD BasketStatus AS JSON_VALUE(CustomerJson, '$.basket.status')

CREATE INDEX IX_Order_BasketStatus
 ON Customer(BasketStatus)
```

> Note: JSON path expressions always begin with a `$` to signify the root of the document, followed by zero or more descendant properties using dotted notation.

And now, we can query on the computed column as we would any other indexed column:

```sql
SELECT *
FROM Customer
WHERE BasketStatus = 'PENDING'
```

Although we are querying on what appears to be an ordinary column named `BasketStatus`, the value is actually being extracted from the JSON content in the `CustomerJson` column, and indexed. The index on the computed column allows SQL Server to efficiently filter rows based on the `$.basket.status` property in each JSON document.

Now let's clean up by dropping the traditional index and removing the computed column:

```sql
DROP INDEX IX_Order_BasketStatus
 ON Customer

ALTER TABLE Customer
 DROP COLUMN BasketStatus
```

## Using the New Native JSON Indexes

While the legacy approach works, it does require creating and maintaining separate computed columns and indexes for each JSON path, which adds storage, maintenance, and write overhead. The new native JSON indexes in SQL Server 2025 address these deficiencies by indexing JSON data directly, delivering faster performance, lower storage costs, and better adaptability as JSON structures evolve.

The following code creates an index named `IX_Customer_CustomerJson_Basket` that **covers the `$.basket` subtree** for the JSON content stored in the `CustomerJson` column of each row, allowing efficient predicates over any path within `basket` (e.g., `$.basket.status`).

```sql
CREATE JSON INDEX IX_Customer_CustomerJson_Basket
ON Customer (CustomerJson)
FOR ('$.basket')
```

Querying from `sys.indexes` reveals a new index type (`type = 9`), which corresponds to JSON indexes.

```sql
SELECT * FROM sys.indexes WHERE type = 9
```

The `sys.json_index_paths` view provides details about the specific JSON paths that the index covers (`$.basket` and all descendant properties).

```sql
SELECT * FROM sys.json_index_paths
```

Before running the next few queries, enable the actual execution plan in SSMS to observe index usage. To do this, click on the "Include Actual Execution Plan" button in the toolbar or press `Ctrl + M`.

> This lab content was created during preview, at which time the optimizer does not automatically select JSON indexes. To ensure the index is utilized, we will provide an index hint in our queries using the `WITH (INDEX(...))` syntax to force its use. When SQL Server 2025 is finally released for general availability , the optimizer will automatically leverage JSON indexes when appropriate.

Now query the `$.basket.status` property, which is covered by the JSON index we defined:

```sql
SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_Basket))
WHERE JSON_VALUE(CustomerJson, '$.basket.status') = 'PENDING'
```

Click on the "Execution Plan" tab in the results pane to see that the JSON index is being used to efficiently seek the relevant rows. This should appear as an "Index Seek" operation in the execution plan. An index seek should perform significantly better than a scan, especially as the size of the `Customer` table grows.

However, if we query a property that is **not** covered by the JSON index (e.g., `$.status`), the index cannot be used, and SQL Server will throw an error if we attempt to force its use:

```sql
SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_Basket))
WHERE JSON_VALUE(CustomerJson, '$.status') = 'processing'
```

Of course, we can still run the query without the index hint, but this will result in a scan of the entire table since there is no suitable index available:

```sql
SELECT *
FROM Customer
WHERE JSON_VALUE(CustomerJson, '$.status') = 'processing'
```

Now check the execution plan again; it should show only a "Clustered Index Scan" operation, indicating that the entire table was scanned.

So let's expand the scope of the JSON index to cover the entire document. Since **only one JSON index can be created per JSON column**, we must first drop the existing index before creating a new one that covers all paths:

```sql
DROP INDEX IX_Customer_CustomerJson_Basket ON Customer
```

Now create a new JSON index named `IX_Customer_CustomerJson_All` to cover the entire document contained in the `CustomerJson` column. The lone `$` represents the root of the document plus all descendants, which includes all JSON properties:

```sql
CREATE JSON INDEX IX_Customer_CustomerJson_All
ON Customer (CustomerJson)
FOR ('$')
```

Querying `sys.json_index_paths` now reveals the path `$`, which covers every single property throughout the entire JSON document:

```sql
SELECT * FROM sys.json_index_paths
```

With this root‑covering index, we can now efficiently query any property within the JSON document. Both of the following queries should leverage the JSON index:

```sql
SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_All))
WHERE JSON_VALUE(CustomerJson, '$.status') = 'processing'

SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_All))
WHERE JSON_VALUE(CustomerJson, '$.basket.status') = 'PENDING'
```

Observe the execution plans for both queries; they should show "Index Seek" operations, indicating that the JSON index is being used effectively no matter what JSON property is queried.

Finally, clean up by dropping the JSON index we created:

```sql
DROP INDEX IX_Customer_CustomerJson_All ON Customer
```

You can also turn off the actual execution plan in SSMS by clicking the "Include Actual Execution Plan" button again or pressing `Ctrl + M`. We won't need to view execution plans for the remaining labs.

___

▶ [Lab: JSON Path Expression Array Enhancements](https://github.com/lennilobel/sql2025-workshop-hol-orlando2025/blob/main/HOL/2.%20JSON%20Support/5.%20JSON%20Path%20Expression%20Array%20Enhancements.md)
