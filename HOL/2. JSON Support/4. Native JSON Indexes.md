## JSON Path Indexing

To enable fast filtering, SQL Server 2025 introduces native JSON indexing. Instead of creating and indexing computed columns, you can declare a JSON index directly on property paths.

This provides an alternative to the legacy approach used in earlier versions of SQL Server. Previously, developers would create **computed columns** based on `JSON_VALUE()` expressions and then index those columns. While effective, this method required more schema scaffolding and introduced some maintenance overhead. It also persisted the computed values, which would consume additional storage.

In contrast, `CREATE JSON INDEX` in SQL Server 2025 allows you to define **JSON path indexes directly** against native `json` columns. SQL Server transparently builds and maintains a specialized index structure behind the scenes, with full awareness of the JSON document structure. These indexes are more efficient, easier to maintain, and allow more expressive querying without schema bloat.

## Indexing JSON Properties with Computed Columns (Legacy Pattern)

First, let's review what is now referred to as the legacy pattern (computed column + B‑tree index). Although the new JSON indexes are preferred, this method remains valid and can still be useful in certain scenarios, especially when dealing with fixed, flat JSON paths and when targeting compatibility with SQL Server versions prior to 2025.

For example, if we are frequently querying the basket status of our customers, then we will certainly want to index the `$.basket.status` property to improve performance. The following snippet shows how to do this using the legacy approach. Simply create a computed column that extracts the desired property using `JSON_VALUE()`, then create a standard index on that computed column:

```sql
ALTER TABLE Customer 
 ADD BasketStatus AS JSON_VALUE(CustomerJson, '$.basket.status')

CREATE INDEX IX_Order_BasketStatus
 ON Customer(BasketStatus)
```

And now, we can query on the computed column as we would any other indexed column:

```sql
SELECT *
FROM Customer
WHERE BasketStatus = 'PENDING'
```

Although we are querying on what appears to be an ordinary column named `BasketStatus`, the value is actually being extracted from the JSON content in the `CustomerJson` column, and indexed. The index on the computed column allows SQL Server to efficiently filter rows based on the `$.basket.status` property in each JSON document.

Now let's clean up by dropping the traditional index and removing the computed column:

```sql
DROP INDEX IX_Order_BasketStatus
 ON Customer

ALTER TABLE Customer
 DROP COLUMN BasketStatus
```

## Native JSON Indexes

While the legacy approach works, it does require creating and maintaining separate computed columns and indexes for each JSON path, which adds storage, maintenance, and write overhead. The new native JSON indexes in SQL Server 2025 address these deficiencies by indexing JSON data directly, delivering faster performance, lower storage costs, and better adaptability as JSON structures evolve.

The following code creates an index that **covers the `$.basket` subtree**, allowing efficient predicates over any path within `basket` (e.g., `$.basket.status`).

```sql
CREATE JSON INDEX IX_Customer_CustomerJson_Basket
ON Customer (CustomerJson)
FOR ('$.basket')
```

Querying from `sys.indexes` reveals a new index type (`type = 9`), which corresponds to JSON indexes.

```sql
SELECT * FROM sys.indexes WHERE type = 9
```

The `sys.json_index_paths` view provides details about the specific JSON paths that the index covers.

```sql
SELECT * FROM sys.json_index_paths
```

Before running the next few queries, enable the actual execution plan in SSMS to observe index usage. To do this, click on the "Include Actual Execution Plan" button in the toolbar or press `Ctrl + M`.

> This lab content was created during preview, at which time the optimizer does not automatically select JSON indexes. To ensure the index is utilized, we will provide an index hint in our queries using the `WITH (INDEX(...))` syntax to force its use. When SQL Server 2025 is finally released for general availability , the optimizer will automatically leverage JSON indexes when appropriate.

Now query the `$.basket.status` property, which is covered by the JSON index we defined:

```sql
SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_Basket))
WHERE JSON_VALUE(CustomerJson, '$.basket.status') = 'PENDING'
```

Click on the "Execution Plan" tab in the results pane to see that the JSON index is being used to efficiently seek the relevant rows. This should appear as an "Index Seek" operation in the execution plan. An index seek should perform significantly better than a scan, especially as the size of the `Customer` table grows.

However, if we query a property that is **not** covered by the JSON index (e.g., `$.status`), the index cannot be used, and SQL Server will throw an error if we attempt to force its use:

```sql
SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_Basket))
WHERE JSON_VALUE(CustomerJson, '$.status') = 'processing'
```

Of course, we can still run the query without the index hint, but this will result in a scan of the entire table since there is no suitable index available:

```sql
SELECT *
FROM Customer
WHERE JSON_VALUE(CustomerJson, '$.status') = 'processing'
```

Now check the execution plan again; it should show only a "Clustered Index Scan" operation, indicating that the entire table was scanned.

So let's expand the scope of the JSON index to cover the entire document. Since only one JSON index can be created per table, we must first drop the existing index before creating a new one that covers all paths:

```sql
DROP INDEX IX_Customer_CustomerJson_Basket ON Customer
```

Now create a new JSON index to cover the entire document (the `$` represents the root of the document, which includes all JSON properties):

```sql
CREATE JSON INDEX IX_Customer_CustomerJson_All
ON Customer (CustomerJson)
FOR ('$')
```

```sql
SELECT * FROM sys.indexes WHERE type = 9
SELECT * FROM sys.json_index_paths
```

```sql
-- The JSON index will be leveraged for any query that references any property in the JSON document
SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_All))
WHERE JSON_VALUE(CustomerJson, '$.status') = 'processing'

SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_All))
WHERE JSON_VALUE(CustomerJson, '$.basket.status') = 'PENDING'
```

```sql
DROP INDEX IX_Customer_CustomerJson_All ON Customer
```

**Create a native JSON index.** The index below **covers the `$.basket` subtree**, allowing efficient predicates over any path within `basket` (e.g., `$.basket.status`).

```sql
-- Now we have native JSON indexes that can point either scalar or complex (nested object/array) properties

-- Create a JSON index that covers the basket property (and all nested properties)
CREATE JSON INDEX IX_Customer_CustomerJson_Basket
ON Customer (CustomerJson)
FOR ('$.basket')
```

**Inspect metadata.** Type `9` identifies JSON indexes. `sys.json_index_paths` shows which paths are materialized for the index key.

```sql
SELECT * FROM sys.indexes WHERE type = 9
SELECT * FROM sys.json_index_paths
```

**Use the index.** During preview, the optimizer may not auto‑select JSON indexes; use an index hint to force it. The first query likely scans; the second should seek via the JSON index.

```sql
-- Execution plan shows no index being used; we must explicitly reference the index with a hint
--  (Preview note: the heuristics for using rowcount and statistics to pick a JSON index for query plan is not complete)
SELECT *
FROM Customer
WHERE JSON_VALUE(CustomerJson, '$.basket.status') = 'PENDING'

-- This query will leverage the JSON index
--  (Preview note: the index hint is required for now, but in the future it will be automatically picked up by the query optimizer)
SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_Basket))
WHERE JSON_VALUE(CustomerJson, '$.basket.status') = 'PENDING'

-- This query generates an error because the JSON index it references does not cover the JSON property being queried ($.status)
/*
SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_Basket))
WHERE JSON_VALUE(CustomerJson, '$.status') = 'processing'
*/
```

**One JSON index per table (current limitation).** Drop and recreate to cover different paths. The following switches to a **document‑wide** index (root `$`), which can satisfy any path predicate.

```sql
-- Only one JSON index can be created per table, so we must drop the previous one before creating a new one
DROP INDEX IX_Customer_CustomerJson_Basket ON Customer
```

```sql
-- Create a JSON index that covers the entire JSON document (with all nested properties)
CREATE JSON INDEX IX_Customer_CustomerJson_All
ON Customer (CustomerJson)
FOR ('$')
```

**Confirm coverage.**

```sql
SELECT * FROM sys.indexes WHERE type = 9
SELECT * FROM sys.json_index_paths
```

**Demonstrate usage.** With a root‑covering index, both predicates below can benefit.

```sql
-- The JSON index will be leveraged for any query that references any property in the JSON document
SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_All))
WHERE JSON_VALUE(CustomerJson, '$.status') = 'processing'

SELECT *
FROM Customer WITH (INDEX (IX_Customer_CustomerJson_All))
WHERE JSON_VALUE(CustomerJson, '$.basket.status') = 'PENDING'
```

**Cleanup for the section.**

```sql
DROP INDEX IX_Customer_CustomerJson_All ON Customer
```


___

▶ [Lab: JSON Path Expression Array Enhancements](https://github.com/lennilobel/sql2025-workshop-hol-orlando2025/blob/main/HOL/2.%20JSON%20Support/5.%20JSON%20Path%20Expression%20Array%20Enhancements.md)
