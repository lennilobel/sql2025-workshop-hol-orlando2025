# The `.modify()` Method

Previously, JSON was stored as `nvarchar`, which meant updates required overwriting the entire document. The new `json` data type supports partial document updates via the `.modify()` method.

## Setup

To demonstrate, let's first create a table with a native JSON column:

```sql
CREATE TABLE Customer
(
  CustomerId    int PRIMARY KEY,
  CustomerJson  json
)
```

This table uses the new `json` data type for the `CustomerJson` column. Unlike `nvarchar(max)`, the `json` type enforces that all stored values are valid JSON. This improves performance, enables rich in-place modifications, and allows JSON-specific indexing and path enforcement.

First, try and insert some invalid JSON to see the validation in action. This statement should fail because the JSON is malformed:

```sql
INSERT INTO Customer
  VALUES (1, '{ "name": "Alice", "age": 30 ')  -- Missing closing brace
```

This statement will also fail because it's not valid JSON at all:

```sql
INSERT INTO Customer
  VALUES (1, 'Just a plain string')
```


Valid JSON will load perfectly of course. Run the following code to add two customers with nested credit cards stored as JSON. This works by using `OPENJSON` to parse and insert multiple rows from the JSON array stored in the `@CustomerJson` variable. Notice how the customer ID is extracted using `JSON_VALUE` for the primary key column, while the entire JSON object is stored in the `CustomerJson` column.

```sql
DECLARE @CustomerJson json = '
  [
    {
      "customerName": "John Doe",
      "customerId": 1001,
      "creditCards": [
        {
          "type": "American Express",
          "number": "675984450768756054",
          "currency": "USD"
        },
        {
          "type": "Visa",
          "number": "3545138777072343",
          "currency": "USD"
        },
        {
          "type": "MasterCard",
          "number": "6397068371771473",
          "currency": "CAD"
        },
        {
          "type": "Discover",
          "number": "6011000990139424",
          "currency": "EUR"
        },
        {
          "type": "JCB",
          "number": "3530111333300000",
          "currency": "GBP"
        }
      ],
      "balance": 25.99,
      "status": "processing",
      "basket": {
        "status": "PENDING",
        "lastUpdated": "2025-06-07T07:32:00Z"
      },
      "preferred": false
    },
    {
      "customerName": "Jane Smith",
      "customerId": 1002,
      "creditCards": [
        {
          "type": "Visa",
          "number": "4111111111111111",
          "currency": "USD"
        },
        {
          "type": "MasterCard",
          "number": "5500000000000004",
          "currency": "CAD"
        }
      ],
      "balance": 99.95,
      "status": "processing",
      "basket": {
        "status": "PENDING",
        "lastUpdated": "2025-05-18T13:18:00Z"
      },
      "preferred": false
    }
  ]
'

INSERT INTO Customer
SELECT
  CustomerId = JSON_VALUE(e.value, '$.customerId'),
  CustomerJson = e.value
FROM
  OPENJSON(@CustomerJson) AS e
```

Now run a quick query to see the inserted data:

```sql
SELECT * FROM Customer
```

You'll need to widen the `CustomerJson` column in the results pane to view the full JSON content. Then scroll right to see all the properties.

> Tip: Double-click the column divider to automatically widen the column to fit the full JSON content.

## Changing Properties

Let’s use `.modify()` to change several JSON properties of a customer. The following code changes the `preferred` property from `false` to `true` and updates the `basket.status` from `"PENDING"` to `"DEAD"` for the customer with `CustomerId = 1002`. Notice how dotted notation is used to navigate into nested objects.

```sql
SELECT * FROM Customer WHERE CustomerId = 1002

UPDATE Customer
SET CustomerJson.modify('$.preferred', 'true')
WHERE CustomerId = 1002

UPDATE Customer
SET CustomerJson.modify('$.basket.status', 'DEAD')
WHERE CustomerId = 1002

SELECT * FROM Customer WHERE CustomerId = 1002
```

Observe the difference between the two `SELECT` results. The `preferred` property has been changed to `true`, and the `basket.status` has been updated to `"DEAD"`.

## Creating and Deleting Properties

You can also create or delete properties. For example, run this code to add a new `priority` property with the value `"high"` to the customer:

```sql
SELECT * FROM Customer WHERE CustomerId = 1002

UPDATE Customer
SET CustomerJson.modify('$.priority', 'high')
WHERE CustomerId = 1002

SELECT * FROM Customer WHERE CustomerId = 1002
```

Observe that the new `priority` property has been appended to the end of the JSON object.

Similarly, `.modify()` can also be used to remove the `priority` property, by supplying `NULL` as the property value:

```sql
SELECT * FROM Customer WHERE CustomerId = 1002

-- Remove an existing field
UPDATE Customer
SET CustomerJson.modify('$.priority', NULL)
WHERE CustomerId = 1002

SELECT * FROM Customer WHERE CustomerId = 1002
```

And now you can see that the `priority` property has been removed.

These examples demonstrate that the `.modify()` method makes JSON updates as natural as relational updates.

___

▶ [Lab: RETURNING Clause](https://github.com/lennilobel/sql2025-workshop-hol-orlando2025/blob/main/HOL/2.%20JSON%20Support/3.%20RETURNING%20Clause.md)
