# Native JSON data type

Since the introduction of JSON support in SQL Server 2016, JSON content needed to be stored as `nvarchar`. This treated the JSON payload as an unstructured string, which offered no storage or performance optimizations.

## Efficient storage with the native `json` type

SQL Server 2025 introduces a true `json` data type with an **internal compact binary format**, which is significantly more space-efficient than storing JSON text in `nvarchar(max)`. SQL Server parses and stores the document in a binary representation optimized for traversal and indexing, reducing memory usage and I/O.

You can observe this difference with `DATALENGTH`, which returns the number of bytes used to store a value. The following example compares storage sizes for the same JSON content stored as `varchar(max)`, `nvarchar(max)`, and native `json`.

In SQL Server Management Studio (SSMS), right-click on the **AdventureWorks2022** database in Object Explorer and select **New Query** to open a new query window. Then execute the following code:

```sql
DECLARE @JsonData_nvarchar nvarchar(max) = N'
[
  {
    "OrderId": 5,
    "CustomerId": 6,
    "OrderDate": "2024-10-10T14:22:27.25-05:00",
    "OrderAmount": 25.9
  },
  {
    "OrderId": 6,
    "CustomerId": 76,
    "OrderDate": "2024-12-10T11:02:36.12-08:00",
    "OrderAmount": 350.25
  },
  {
    "OrderId": 7,
    "CustomerId": 9,
    "OrderDate": "2024-10-10T14:22:27.25-05:00",
    "OrderAmount": 862.75
  },
  {
    "OrderId": 8,
    "CustomerId": 7,
    "OrderDate": "2024-12-10T11:02:36.12-08:00",
    "OrderAmount": 591.95
  },
  {
    "OrderId": 9,
    "CustomerId": 15,
    "OrderDate": "2024-10-10T14:22:27.25-05:00",
    "OrderAmount": 8510.00
  },
  {
    "OrderId": 10,
    "CustomerId": 2,
    "OrderDate": "2024-12-10T11:02:36.12-08:00",
    "OrderAmount": 871.10
  }
]'

DECLARE @JsonData_varchar  varchar(max)   = CAST(@JsonData_nvarchar AS varchar(max))
DECLARE @JsonData_json     json           = CAST(@JsonData_nvarchar AS json)

SELECT
  Length_varchar  = DATALENGTH(@JsonData_varchar),
  Length_nvarchar = DATALENGTH(@JsonData_nvarchar),
  Length_json     = DATALENGTH(@JsonData_json)
```

The results should indicate:

* `varchar(max)` size: 781 bytes
* `nvarchar(max)` size: 1,562 bytes (due to 2 bytes per Unicode character)
* `json` size: 529 bytes (thanks to its compact binary storage format)

This highlights a dramatic advantage of the `json` type: **even while preserving full Unicode fidelity like `nvarchar(max)`, it consumes significantly less space**—in this case, a reduction from 1,562 bytes to just 529 bytes. This efficiency translates to reduced I/O, lower memory pressure, and better performance overall when working with large-scale JSON datasets.

The `json` data type in SQL Server inherently supports Unicode, similar to `nvarchar`. This makes it safer than `varchar` for multilingual data and avoids the risk of character loss or corruption. Yet, even while stripped of the overhead of Unicode, it still consumes more space at 781 bytes, compared to the Unicode-supporting version of the same content stored in the `json` data type at 529 bytes.


___

▶ [Lab: The .modify() Method](https://github.com/lennilobel/sql2025-workshop-hol-orlando2025/blob/main/HOL/2.%20JSON%20Support/2.%20The%20.modify()%20Method.md)

