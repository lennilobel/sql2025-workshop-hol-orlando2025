# JSON_CONTAINS

`JSON_CONTAINS` lets you ask a simple yes/no question of JSON data: **“Does this path contain this value?”** It returns `1` if a match is found and `0` otherwise. Unlike `FOR JSON`, which formats query results, `JSON_CONTAINS` is a *predicate-style* function you can use inside `SELECT`, `WHERE`, or `CASE` expressions to drive filtering and conditional logic.

This lab walks through targeted lookups across scalar values, arrays, nested arrays, and arrays of objects. You’ll see how **path expressions** (with wildcards) and **type-awareness** (e.g., numbers vs strings vs booleans) affect the result. The examples below are self‑contained and can be run independently.

**General behavior:**
- The first argument is the *document to search*.
- The second is the *value to find* (scalar or JSON literal).
- The third is the *JSON path* to search within; wildcards and array selectors are supported.

> **Tip:** `JSON_CONTAINS(source_json, value, path)` is **type-sensitive**. Searching for the string `'1'` is not the same as searching for the number `1`, and booleans must be provided as `bit` (or `true`/`false` literals where supported).

The examples below demonstrate containment of integers, strings, booleans, and nested array values, including searching across all objects in a root‑level array.

## Search for an integer value in a JSON path

We’ll start by scanning a root-level property. The path `$.customerId` targets a property named `customerId` at the root of the document. The function returns `1` if any value at that path equals `1001`.

```sql
DECLARE @JsonData json = '{
  "customerId": 1001,
  "basket": {
    "totalItems": 4,
    "labels": ["oversized", "fragile", "heavy"]
  },
  "items": [3, {"quantities": [13, 89, 92]}, true],
  "discount": null,
  "preferred": true
}'

SELECT Found =
  JSON_CONTAINS(
    @JsonData,      -- Scan this JSON content
    1001,           -- Search for this value
    '$.customerId'  -- In a root-level property named "customerId"
  )

GO
```

Observe that `JSON_CONTAINS` returns `1` because the `$.customerId` path matches the value `1001`. If you searched for a different number (e.g., `2002`), it would return `0` since that value is not present at that path.

## Search for a string value in an array

Here we look inside an array with the wildcard operator `[*]`. The path `$.basket.labels[*]` instructs `JSON_CONTAINS` to check **every element** in the `labels` array for the string `'fragile'`:

```sql
DECLARE @JsonData json = '{
  "customerId": 1001,
  "basket": {
    "totalItems": 4,
    "labels": ["oversized", "fragile", "heavy"]
  },
  "items": [3, {"quantities": [13, 89, 92]}, true],
  "discount": null,
  "preferred": true
}'

SELECT Found =
  JSON_CONTAINS(
    @JsonData,            -- Scan this JSON content
    'fragile',            -- Search for this value
    '$.basket.labels[*]'  -- In all elements in the "labels" array inside the "basket" object
  )

GO
```

Observe that `JSON_CONTAINS` returns `1` because the `labels` array contains the string `'fragile'`. If you searched for a different string (e.g., `'priority'`), it would return `0` since that value is not present in the array.

## Search for a boolean value in an array

Booleans require attention to type. In this example, the `items` array contains various JSON types—including an explicit `true`. We cast to `bit` to ensure a type-accurate comparison (`1` equals `true`).

```sql
DECLARE @JsonData json = '{
  "customerId": 1001,
  "customerId": 2002,
  "basket": {
    "totalItems": 4,
    "labels": ["oversized", "fragile", "heavy"]
  },
  "items": [3, {"quantities": [13, 89, 92]}, true],
  "discount": null,
  "preferred": true
}'

SELECT Found =
  JSON_CONTAINS(
    @JsonData,      -- Scan this JSON content
    CAST(1 AS bit), -- Search for this value (true)
    '$.items[*]'    -- In all elements in the "items" array
  )

GO
```

Observe that `JSON_CONTAINS` returns `1` because the `items` array contains the boolean `true`. If you searched for `CAST(0 AS bit)` (i.e., `false`), it would return `0` since that value is not present in the array. Similarly, searching for `1` without casting would also return `0`, because there is no numeric `1` in the array.

## Search inside a nested array

Paths can chain wildcards to drill into nested structures. The path `$.items[*].quantities[*]` navigates into any object within `items` that has a `quantities` array, and checks **all** of those nested values for `89`.

```sql
DECLARE @JsonData json = '{
  "customerId": 1001,
  "customerId": 2002,
  "basket": {
    "totalItems": 4,
    "labels": ["oversized", "fragile", "heavy"]
  },
  "items": [3, {"quantities": [13, 89, 92]}, true],
  "discount": null,
  "preferred": true
}'

SELECT Found =
  JSON_CONTAINS(
    @JsonData,                  -- Scan this JSON content
    89,                         -- Search for this value
    '$.items[*].quantities[*]'  -- In all values inside "quantities" arrays found in any object within the "items" array
  )

GO
```

Observe that `JSON_CONTAINS` returns `1` because the `quantities` array nested within the `items` array contains the value `89`. If you searched for any other number not present in the nested array (e.g., `42`), it would return `0`.

## Search within an array of objects

Finally, consider a root-level JSON array where each element is an object. The path `$[*].customerId` iterates every array element and tests the `customerId` property for a match (`1056`).

```sql
DECLARE @JsonData json = '[
  {"customerId": 1001, "customerId": 2002, "priority": 1},
  {"customerId": 329, "customerId": 1343, "priority": 1},
  {"customerId": 1056, "customerId": 80, "priority": 3},
  {"customerId": 871, "customerId": 232, "priority": 2}
]'

SELECT Found =
  JSON_CONTAINS(
    @JsonData,    -- Scan this JSON content
    1056,       -- Search for this value
    '$[*].customerId'  -- In the "customerId" field in every object in the root-level array
  )

GO
```

Observe that `JSON_CONTAINS` returns `1` because one of the objects in the root-level array has a `customerId` of `1056`. If you searched for a different number (e.g., `9999`), it would return `0` since no object in the array has that value.

This pattern is ideal for “does any object match?” checks across large arrays—common in event logs, shopping carts, or batched API payloads.

## Wrap‑Up

- `JSON_CONTAINS` is **type-aware**—ensure your search value’s type matches the JSON value (e.g., number vs text vs boolean).
- Use **wildcards** (`[*]`) to scan arrays and chain them to reach nested arrays/objects.
- Works well in predicates: combine with `WHERE`, `CASE`, or computed columns for flexible filtering and shaping.

That’s it—you can now quickly test for the presence of values anywhere within a JSON document using concise path expressions.

___

▶ [Change Event Streaming](https://github.com/lennilobel/sql2025-workshop-hol-orlando2025/tree/main/HOL/3.%20Change%20Event%20Streaming)

