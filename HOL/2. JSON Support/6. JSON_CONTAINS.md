# JSON_CONTAINS

`JSON_CONTAINS` lets you ask a simple yes/no question of JSON data: **“Does this path contain this value?”** It returns `1` if a match is found and `0` otherwise. Unlike `FOR JSON`, which formats query results, `JSON_CONTAINS` is a *predicate-style* function you can use inside `SELECT`, `WHERE`, or `CASE` expressions to drive filtering and conditional logic.

This lab walks through targeted lookups across scalar values, arrays, nested arrays, and arrays of objects. You’ll see how **path expressions** (with wildcards) and **type-awareness** (e.g., numbers vs strings vs booleans) affect the result. The examples below are self‑contained and can be run independently.

> **Tip:** `JSON_CONTAINS(source_json, value, path)` is **type-sensitive**. Searching for the string `'1'` is not the same as searching for the number `1`, and booleans must be provided as `bit` (or `true`/`false` literals where supported).

---

## 1) Search for an integer value in a JSON path

We’ll start by scanning a root-level property. The path `$.customerId` targets a property named `customerId` at the root of the document. The function returns `1` if any value at that path equals `1001`.

```sql
-- Search for an integer value in a JSON path
DECLARE @JsonData json = '{
  "customerId": 1001,
  "customerId": 2002,
  "basket": {
    "totalItems": 4,
    "labels": ["fragile"]
  },
  "items": [1, 3, {"quantities": [89]}, false],
  "discount": null,
  "preferred": true
}'

SELECT Found =
  JSON_CONTAINS(
    @JsonData,    -- Scan this JSON content
    1001,       -- Search for this value
    '$.customerId'   -- In a root-level property named "customerId"
  )

GO
```

> **Note:** If the JSON contains duplicate keys, JSON semantics typically favor the **last** occurrence. Behavior can vary by system; this example focuses on the containment question rather than key de-duplication rules.

---

## 2) Search for a string value in an array

Here we look inside an array with the wildcard operator `[*]`. The path `$.basket.labels[*]` instructs `JSON_CONTAINS` to check **every element** in the `labels` array for the string `'fragile'`.

```sql
-- Search for a string value in a JSON path
DECLARE @JsonData json = '{
  "customerId": 1001,
  "customerId": 2002,
  "basket": {
    "totalItems": 4,
    "labels": ["fragile"]
  },
  "items": [1, 3, {"quantities": [89]}, false],
  "discount": null,
  "preferred": true
}'

SELECT Found =
  JSON_CONTAINS(
    @JsonData,        -- Scan this JSON content
    'fragile',        -- Search for this value
    '$.basket.labels[*]'  -- In all elements in the "labels" array inside the "basket" object
  )

GO
```

> **Tip:** Use `[*]` whenever you want to test *any* element within an array for a match.

---

## 3) Search for a boolean value in an array

Booleans require attention to type. In this example, the `items` array contains various JSON types—including an explicit `true`. We cast to `bit` to ensure a type-accurate comparison (`1` equals `true`).

```sql
-- Search for a bit (boolean) value in a JSON array
DECLARE @JsonData json = '{
  "customerId": 1001,
  "customerId": 2002,
  "basket": {
    "totalItems": 4,
    "labels": ["fragile"]
  },
  "items": [1, 3, {"quantities": [89]}, true],
  "discount": null,
  "preferred": true
}'

SELECT Found =
  JSON_CONTAINS(
    @JsonData,      -- Scan this JSON content
    CAST(1 AS bit),   -- Search for this value (true)
    '$.items[*]'    -- In all elements in the "items" array
  )

GO
```

> **Why cast?** Treating `true` as text (e.g., `'true'`) won’t match a boolean. Casting ensures the correct JSON type is compared.

---

## 4) Search inside a nested array

Paths can chain wildcards to drill into nested structures. The path `$.items[*].quantities[*]` navigates into any object within `items` that has a `quantities` array, and checks **all** of those nested values for `89`.

```sql
-- Search for an integer value contained within a nested JSON array
DECLARE @JsonData json = '{
  "customerId": 1001,
  "customerId": 2002,
  "basket": {
    "totalItems": 4,
    "labels": ["fragile"]
  },
  "items": [1, 3, {"quantities": [89]}, false],
  "discount": null,
  "preferred": true
}'

SELECT Found =
  JSON_CONTAINS(
    @JsonData,          -- Scan this JSON content
    89,             -- Search for this value
    '$.items[*].quantities[*]'  -- In all values inside "quantities" arrays found in any object within the "items" array
  )

GO
```

This is a powerful pattern for nested JSON: **array-of-objects → array property → elements**.

---

## 5) Search within an array of objects

Finally, consider a root-level JSON array where each element is an object. The path `$[*].customerId` iterates every array element and tests the `customerId` property for a match (`1056`).

```sql
-- Search for an integer value contained within a JSON object in a JSON array
DECLARE @JsonData json = '[
  {"customerId": 1001, "customerId": 2002, "priority": 1},
  {"customerId": 329, "customerId": 1343, "priority": 1},
  {"customerId": 1056, "customerId": 80, "priority": 3},
  {"customerId": 871, "customerId": 232, "priority": 2}
]'

SELECT Found =
  JSON_CONTAINS(
    @JsonData,    -- Scan this JSON content
    1056,       -- Search for this value
    '$[*].customerId'  -- In the "customerId" field in every object in the root-level array
  )

GO
```

This pattern is ideal for “does any object match?” checks across large arrays—common in event logs, shopping carts, or batched API payloads.

---

## Wrap‑Up

- `JSON_CONTAINS` is **type-aware**—ensure your search value’s type matches the JSON value (e.g., number vs text vs boolean).
- Use **wildcards** (`[*]`) to scan arrays and chain them to reach nested arrays/objects.
- Works well in predicates: combine with `WHERE`, `CASE`, or computed columns for flexible filtering and shaping.

That’s it—you can now quickly test for the presence of values anywhere within a JSON document using concise path expressions.









## Flexible Matching with `JSON_CONTAINS`

`JSON_CONTAINS` checks whether a **candidate value or structure** is present at a path (or set of paths) inside a JSON document. It is **type‑aware** and understands arrays, objects, and scalars. This eliminates brittle text searches and reduces the need to shred data for simple containment predicates.

**General behavior:**
- The first argument is the *document to search*.
- The second is the *value to find* (scalar or JSON literal).
- The third is the *JSON path* to search within; wildcards and array selectors are supported.

**Examples below** demonstrate containment of integers, strings, booleans, and nested array values, including searching across all objects in a root‑level array.








**Notes & tips:**
- `JSON_CONTAINS` compares using JSON semantics—number vs string types are distinct.
- Paths with wildcards (`[*]`) search across all array elements; combine with dotted paths to inspect nested structures.
- For complex containment (e.g., “object with specific subset of properties”), use a JSON literal as the second argument (not just a scalar).


**Cleanup.**

```sql
-- Clean up
DROP TABLE SampleData
DROP TABLE Customer
DROP TABLE Account
```

___








