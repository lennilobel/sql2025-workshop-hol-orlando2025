## JSON Path Expression Array Enhancements

SQL Server 2025 expands JSON path syntax so you can address **array elements with wildcards, ranges, and positional lists**, and it adds support for `last` to reference the final element. This makes extraction and containment checks far more expressive without resorting to `OPENJSON` hacks.

## Before SQL Server 2025

Prior to SQL Server 2025, you could reference fixed positions only (`[0]`, `[1]`) and then apply dotted notation into those objects for fields like `type`. For example:

```sql
SELECT
  CustomerId,
  AllCreditCards        = JSON_QUERY(CustomerJson, '$.creditCards'),
  FirstCreditCard       = JSON_QUERY(CustomerJson, '$.creditCards[0]'),
  FirstCreditCardType   = JSON_VALUE(CustomerJson, '$.creditCards[0].type'),
  SecondCreditCard      = JSON_QUERY(CustomerJson, '$.creditCards[1]'),
  SecondCreditCardType  = JSON_VALUE(CustomerJson, '$.creditCards[1].type'),
  NinthCreditCard       = JSON_QUERY(CustomerJson, '$.creditCards[8]'),
  NinthCreditCardType   = JSON_VALUE(CustomerJson, '$.creditCards[8].type')
FROM
  Customer
```

Notice that this returns the first, second, and ninth credit cards in the array, and their types. Since no customer has nine credit cards, the ninth card and its type return `NULL`.

## SQL Server 2025 Enhancements

In SQL Server 2025, wildcards (`[*]`), ranges (`[0 to 2]`), positional lists (`[0, last]`), and `last` enable batch extraction. And the `WITH ARRAY WRAPPER` syntax ensures the result is always an array even when paths match a single element.

```sql
SELECT
  CustomerId,
  AllCreditCardsBad          = JSON_QUERY(c.CustomerJson, '$.creditCards[*]'),
  AllCreditCards             = JSON_QUERY(c.CustomerJson, '$.creditCards[*]' WITH ARRAY WRAPPER),
  AllCreditCardTypes         = JSON_QUERY(c.CustomerJson, '$.creditCards[*].type' WITH ARRAY WRAPPER),
  FirstThreeCreditCardTypes  = JSON_QUERY(c.CustomerJson, '$.creditCards[0 to 2].type' WITH ARRAY WRAPPER),
  LastCreditCardType         = JSON_VALUE(c.CustomerJson, '$.creditCards[last].type'),
  FirstAndLastCreditCardType = JSON_QUERY(c.CustomerJson, '$.creditCards[0, last].type' WITH ARRAY WRAPPER),
  LastAndFirstCreditCardType = JSON_QUERY(c.CustomerJson, '$.creditCards[last, 0].type' WITH ARRAY WRAPPER),
  EveryOtherCreditCardType   = JSON_QUERY(c.CustomerJson, '$.creditCards[0, 2, 4, 6, 8].type' WITH ARRAY WRAPPER)
FROM
  Customer AS c
```

Observe the following results:

| | |
|-|-|
| `AllCreditCardsBad` | Uses the wildcard `[*]` but does not use `WITH ARRAY WRAPPER`. When the path matches multiple elements, it returns `NULL` unless you include `WITH ARRAY_WRAPPER`. |
| `AllCreditCards` | Uses the wildcard `[*]` and includes `WITH ARRAY WRAPPER`, so it returns all credit cards in an array. |
| `AllCreditCardTypes` | Uses the wildcard `[*]` and includes `WITH ARRAY WRAPPER`, so it returns all credit card types in an array. |
| `FirstThreeCreditCardTypes` | Uses the range `[0 to 2]` and includes `WITH ARRAY WRAPPER`, so it returns the types of the first three credit cards in an array. |
| `LastCreditCardType` | Uses `last` to return the type of the last credit card. |
| `FirstAndLastCreditCardType` | Uses the positional list `[0, last]` and includes `WITH ARRAY WRAPPER`, so it returns the types of the first and last credit cards in an array. |
| `LastAndFirstCreditCardType` | Uses the positional list `[last, 0]` and includes `WITH ARRAY WRAPPER`, so it returns the types of the last and first credit cards in an array. |
| `EveryOtherCreditCardType` | Uses the positional list `[0, 2, 4, 6, 8]` and includes `WITH ARRAY WRAPPER`, so it returns the types of every other credit card in an array (for up to the first nine credit cards). |

___

▶ [Lab: JSON Aggregates](https://github.com/lennilobel/sql2025-workshop-hol-orlando2025/blob/main/HOL/2.%20JSON%20Support/6.%20JSON%20Aggregates.md)
