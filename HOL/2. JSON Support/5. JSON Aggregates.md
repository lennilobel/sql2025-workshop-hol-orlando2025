# JSON Aggregates

SQL Server 2025 introduces **JSON aggregate functions** that allow you to efficiently combine multiple rows of relational data into JSON arrays and objects. These new functions—`JSON_ARRAYAGG` and `JSON_OBJECTAGG`—let you generate hierarchical JSON directly in T‑SQL without requiring a `FOR JSON` clause or subqueries. This is especially useful for constructing nested JSON documents and simplifying data shaping for APIs and reports.

Whereas `FOR JSON` is a query-level construct that formats result sets as JSON, these aggregate functions behave like traditional aggregates (`COUNT`, `SUM`, `AVG`, etc.), making them composable within larger queries. And, like other aggregate functions, you can combine them with either `GROUP BY` or `OVER (PARTITION BY ...)` clauses to produce grouped or windowed JSON results.

## Setup

Let's setup some tables to demonstrate JSON aggregates. We'll create a simple `Customer` table and a related `Order` table to represent customers and their orders, and populate them with sample data:

```sql
DROP TABLE IF EXISTS [Order]
DROP TABLE IF EXISTS Customer
GO

CREATE TABLE Customer (
  CustomerId    int PRIMARY KEY,
  CustomerName  varchar(50) UNIQUE,
  Balance       decimal(10, 2)
)

INSERT INTO Customer
  (CustomerId, CustomerName,  Balance) VALUES
  (1,          'Carl Rivera', 559.25),
  (2,          'Danel Smith', 1024.50),
  (3,          'John Astor', 209.87)

CREATE TABLE [Order] (
  OrderId      int PRIMARY KEY,
  CustomerId   int REFERENCES Customer(CustomerId),
  OrderNumber  varchar(10) UNIQUE,
  ProductName  varchar(20),
  OrderStatus  varchar(10),
  Amount       decimal(10, 2)
)

INSERT INTO [Order]
  (OrderId, CustomerId, OrderNumber, ProductName, OrderStatus, Amount) VALUES
  (1,       1,          'SO1231',    'Laptop',    'PENDING',   1200.50),
  (2,       1,          'SO1232',    'Mouse',     'SHIPPED',     25.99),
  (3,       1,          'SO1233',    'Keyboard',  'SHIPPED',     75.49),
  (4,       2,          'SO1234',    'Laptop',    'SHIPPED',   1300.50),
  (5,       2,          'SO1235',    'Dock',      'SHIPPED',    200.00),
  (6,       3,          'SO1236',    'Mouse',     'PENDING',     25.99),
  (7,       3,          'SO1237',    'Mouse',     'SHIPPED',     35.99)
```

The sample data represents three customers, each with one or more orders. Before continuing, you can query both tables to verify the data:

```sql
SELECT * FROM Customer
SELECT * FROM [Order]
```

## Querying Orders

The `JSON_ARRAYAGG` and `JSON_OBJECTAGG` functions are used to aggregate rows into JSON arrays and objects respectively. Think of them as JSON‑aware versions of `STRING_AGG`, but instead of concatenating strings, they generate well‑formed JSON.

The simplest example is to aggregate order amounts across the entire `[Order]` table. Since there’s no `GROUP BY` clause, the entire table is treated as one group:

```sql
SELECT
  AllOrderAmountsTotal  = SUM(Amount),
  AllOrderAmountsArray  = JSON_ARRAYAGG(Amount),
  AllOrderAmountsObject = JSON_OBJECTAGG(OrderNumber: Amount)
FROM
  [Order]
```

The first column (`AllOrderAmountsTotal`) uses a traditional numeric aggregate, while the next two use JSON aggregates.  
* `JSON_ARRAYAGG` produces an array of all order amounts, e.g. `[1200.5, 25.99, 75.49, ...]`.  
* `JSON_OBJECTAGG` produces an object where each property name is the `OrderNumber`, and its value is the corresponding `Amount`.

### JSON Aggregates with GROUP BY

Next, by grouping by `CustomerId`, we can aggregate the same values per customer. This produces one row per customer, each with an array or object representing their individual orders.

```sql
SELECT
  CustomerId,
  OrderAmountsTotal   = SUM(Amount),
  OrderAmountsArray   = JSON_ARRAYAGG(Amount),
  OrderAmountsObject  = JSON_OBJECTAGG(OrderNumber: Amount)
FROM
  [Order]
GROUP BY
  CustomerId
```

Each customer now has their own JSON array of order amounts and a JSON object keyed by order number. This makes it easy to shape relational data into hierarchical JSON structures without joins or subqueries.

### Enriching JSON with Objects

Let’s make our JSON more descriptive. Instead of aggregating only numeric values, we can aggregate full order objects. To do this, we pass a `JSON_OBJECT` constructor into `JSON_ARRAYAGG`. This nests order details inside each array element. Likewise, we can use `JSON_OBJECTAGG` to produce a single JSON object keyed by order number, with each value representing an entire order.

```sql
SELECT
  CustomerId,
  OrderAmountsTotal = SUM(Amount),
  OrderAmountsArray = JSON_ARRAYAGG(Amount),
  OrdersArray       = JSON_ARRAYAGG(JSON_OBJECT(
                        'OrderNumber': OrderNumber,
                        'ProductName': ProductName,
                        'OrderStatus': OrderStatus,
                        'Amount': Amount
                      )),
  OrdersObject      = JSON_OBJECTAGG(OrderNumber: JSON_OBJECT(
                        'ProductName': ProductName,
                        'OrderStatus': OrderStatus,
                        'Amount': Amount
                      ))
FROM
  [Order]
GROUP BY
  CustomerId
```

Now each `OrdersArray` column contains a proper JSON array of objects such as:

```json
[
  { "OrderNumber": "SO1231", "ProductName": "Laptop", "OrderStatus": "PENDING", "Amount": 1200.5 },
  { "OrderNumber": "SO1232", "ProductName": "Mouse", "OrderStatus": "SHIPPED", "Amount": 25.99 }
]
```

and each `OrdersObject` column contains a dictionary-like structure keyed by order number.

### Further Enrich JSON by Joining Orders on Customer

To enrich the data further, we can join each on their parent `Customer` row to include customer names and produce nested objects with parent/child information. Also notice the use of nested `JSON_OBJECT` expressions to construct JSON with a custom hierarchical shape.

```sql
SELECT
  o.CustomerId,
  OrderAmountsTotal = SUM(o.Amount),
  OrderAmountsArray = JSON_ARRAYAGG(o.Amount),
  OrdersArray       = JSON_ARRAYAGG(JSON_OBJECT(
                        'OrderNumber': o.OrderNumber,
                        'CustomerName': c.CustomerName,
                        'OrderDetails': JSON_OBJECT(
                          'ProductName': o.ProductName,
                          'OrderStatus': o.OrderStatus,
                          'Amount': o.Amount
                        )
                      )),
  OrdersObject      = JSON_OBJECTAGG(o.OrderNumber: JSON_OBJECT(
                        'CustomerName': c.CustomerName,
                        'OrderDetails': JSON_OBJECT(
                          'ProductName': o.ProductName,
                          'OrderStatus': o.OrderStatus,
                          'Amount': o.Amount
                        )
                      ))
FROM
  [Order] AS o
  INNER JOIN Customer AS c ON c.CustomerId = o.CustomerId
GROUP BY
  o.CustomerId,
  c.CustomerName
```

This approach makes it possible to produce nested JSON output representing both customer and order data—perfect for REST or GraphQL APIs that expect JSON hierarchies.

## Querying Customers

We can also use JSON aggregates directly against the `Customer` table. In this example, we’ll summarize balances for all customers using `JSON_ARRAYAGG` and `JSON_OBJECTAGG`.

```sql
SELECT
  AllCustomerBalancesTotal  = SUM(Balance),
  AllCustomerBalancesArray  = JSON_ARRAYAGG(Balance),
  AllCustomerBalancesObject = JSON_OBJECTAGG(CustomerName: Balance)
FROM
  Customer
```

This query outputs an array of all balances, an object keyed by customer name, and the total sum—all in a single query. It’s a concise and expressive way to shape JSON summaries from relational data.

### Combining Customer and Order Data

Now let’s bring customer and order data together again. This time, we’ll aggregate order information by customer using both scalar and object forms. Notice that we can build multiple JSON aggregates in the same query for different hierarchical structures.

```sql
SELECT
  c.CustomerId,
  c.CustomerName,
  OrderAmountsTotal         = SUM(o.Amount),
  OrderAmountsArray         = JSON_ARRAYAGG(o.Amount),
  OrderAmountsByProduct     = JSON_OBJECTAGG(o.ProductName: o.Amount),
  OrderStatusesByProduct    = JSON_OBJECTAGG(o.ProductName: o.OrderStatus)
FROM
  Customer AS c
  INNER JOIN [Order] AS o ON o.CustomerId = c.CustomerId
GROUP BY
  c.CustomerId,
  c.CustomerName
```

Each row now includes arrays and objects representing each customer’s orders, grouped by product and status. These shapes are ideal for downstream JSON consumption in applications or APIs.

### Richer JSON Structures

We can go one step further by creating even richer JSON using composite keys and nested objects. The following query demonstrates several variations of JSON aggregation in a single statement.

```sql
SELECT
  c.CustomerId,
  c.CustomerName,
  CustomerOrdersArray           = JSON_ARRAYAGG(JSON_OBJECT(
                                    'OrderNumber': o.OrderNumber,
                                    'ProductName': o.ProductName,
                                    'OrderStatus': o.OrderStatus,
                                    'Amount': o.Amount
                                  )),
  CustomerOrdersObject          = JSON_OBJECTAGG(o.OrderNumber: JSON_OBJECT(
                                   'ProductName': o.ProductName,
                                   'OrderStatus': o.OrderStatus,
                                   'Amount': o.Amount
                                  )),
  CustomerOrderStatusesArray    = JSON_ARRAYAGG(JSON_OBJECT(
                                    'OrderNumber': o.OrderNumber,
                                    'OrderStatus': o.OrderStatus
                                  )),
  CustomerOrderStatusesObject   = JSON_OBJECTAGG(o.OrderNumber: o.OrderStatus),
  CustomerOrderAmountsByProduct = JSON_OBJECTAGG(o.ProductName || '_' || o.OrderNumber: o.Amount),
  CustomerOrderAmountsTotal     = SUM(Amount),
  CustomerOrderAmountsArray     = JSON_ARRAYAGG(Amount)
FROM
  Customer AS c
  INNER JOIN [Order] AS o ON o.CustomerId = c.CustomerId
GROUP BY
  c.CustomerId,
  c.CustomerName
```

This produces JSON objects keyed by concatenated strings (such as `"Mouse_SO1237"`) to ensure uniqueness when multiple orders share the same product name.

## JSON Aggregates with Windowing

In addition to `GROUP BY`, JSON aggregates can also be used as **window functions** with the `OVER` clause. This allows you to compute JSON arrays or objects for each row without collapsing the result set into groups.

For example, we can show every order but still include a JSON array of all orders per customer alongside it:

```sql
SELECT
  o.OrderId,
  o.CustomerId,
  o.OrderNumber,
  OrdersForCustomer = JSON_ARRAYAGG(o.OrderNumber) OVER (PARTITION BY o.CustomerId)
FROM
  [Order] AS o
ORDER BY
  o.CustomerId,
  o.OrderId
```

Here, the `PARTITION BY` clause ensures that each order row includes the aggregated JSON array of orders for its respective customer. This pattern can be particularly useful for analytics or UI queries that need both detail and context in a single result set.

## JSON Aggregates with GROUPING SETS

`GROUPING SETS` allow you to define multiple grouping combinations in a single query. When combined with JSON aggregates, they can produce multi-level JSON summaries across different dimensions (e.g., per customer, per order status, or both).

The following query demonstrates this concept:

```sql
SELECT
  CustomerId,
  OrderStatus,
  GroupedAmountsArray       = JSON_ARRAYAGG(Amount),
  GroupedAmountsByProduct   = JSON_OBJECTAGG(ProductName:Amount),
  GroupedAmountsTotal       = SUM(Amount)
FROM
  [Order]
GROUP BY
  GROUPING SETS (
    (CustomerId),             -- Group by Customer only
    (OrderStatus),            -- Group by OrderStatus only
    (CustomerId, OrderStatus),-- Group by both
    ()                        -- Grand total (no grouping)
  )
ORDER BY
  CustomerId,
  OrderStatus
```

This query generates JSON summaries for multiple levels of aggregation in one pass—allowing you to explore totals by customer, by status, by both, and overall. JSON aggregates naturally adapt to each grouping level.

---

## Clean Up

Finally, drop the demo tables to leave your environment clean:

```sql
DROP TABLE IF EXISTS [Order]
DROP TABLE IF EXISTS Customer
GO
```

You’ve now seen how to use JSON aggregate functions to produce rich, hierarchical JSON directly from T‑SQL queries—without resorting to procedural code or post-processing.

These new features make SQL Server 2025 a powerful platform for building JSON-based APIs, analytics dashboards, and modern data applications.

___

▶ [Lab: JSON_CONTAINS](https://github.com/lennilobel/sql2025-workshop-hol-orlando2025/blob/main/HOL/2.%20JSON%20Support/6.%20JSON_CONTAINS.md)
