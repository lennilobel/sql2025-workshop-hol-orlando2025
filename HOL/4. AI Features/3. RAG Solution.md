# Retrieval-Augmented Generation (RAG) with AdventureWorks and Chat Completions

This lab builds directly on the previous **Vector Search with DiskANN and External AI Models** lab. You will now implement a complete **Retrieval-Augmented Generation (RAG)** solution using product data from the **AdventureWorks2022** database.

The lab introduces a new capability: turning search results into **natural language responses** using a **chat completions model**. You will retrieve relevant data using vector search (as before), and then pass that data into a GPT model to create a conversational, human-friendly response.

This is the same architecture used by AI copilots, assistants, and RAG-based applications — now implemented directly inside SQL Server 2025.

---

## Preparing the Unified Product View

To support rich vectorization and natural language generation, we need to **flatten** our relational schema into a single row per product. This denormalized view will include:

* Product name and description
* Product category and model name
* Color, size, and price
* Safety stock and reorder levels

This view will serve two purposes:

1. **Embedding source** for vector generation
2. **Context payload** for GPT input

```sql
CREATE OR ALTER VIEW ProductSearchView AS
SELECT 
  p.ProductID,
  ProductName = p.Name,
  ProductDescription = pd.Description,
  CategoryName = pc.Name,
  ModelName = pm.Name,
  p.Color,
  p.Size,
  p.ListPrice,
  p.SafetyStockLevel,
  p.ReorderPoint
FROM Production.Product p
JOIN Production.ProductModel pm ON p.ProductModelID = pm.ProductModelID
JOIN Production.ProductModelProductDescriptionCulture pmpdc ON pmpdc.ProductModelID = pm.ProductModelID
JOIN Production.ProductDescription pd ON pd.ProductDescriptionID = pmpdc.ProductDescriptionID
JOIN Production.ProductSubcategory psc ON p.ProductSubcategoryID = psc.ProductSubcategoryID
JOIN Production.ProductCategory pc ON psc.ProductCategoryID = pc.ProductCategoryID
WHERE pmpdc.CultureID = 'en'
```

Query this view to see the full product context flattened into a single row per product:

```sql
SELECT TOP 5 * FROM ProductSearchView
```

---

## Storing Product Vectors

To support RAG, we need a table that stores both the full JSON for each product and its associated vector.

```sql
CREATE TABLE Production.ProductRagIndex (
  ProductRagIndexID int IDENTITY PRIMARY KEY,
  ProductID int NOT NULL,
  ProductJson nvarchar(max),
  ProductVector vector(1536),
  FOREIGN KEY (ProductID) REFERENCES Production.Product(ProductID)
)
```

Each row in this table represents a searchable document in our RAG index.

---

## Populating the ProductRagIndex Table

We will transform each row in `ProductSearchView` into a JSON document and vectorize it for similarity search. This preserves both structure and meaning.

```sql
TRUNCATE TABLE Production.ProductRagIndex

INSERT INTO Production.ProductRagIndex (ProductID, ProductJson)
SELECT 
  ProductID,
  (
    SELECT * 
    FROM ProductSearchView AS v 
    WHERE v.ProductID = p.ProductID 
    FOR JSON AUTO, WITHOUT_ARRAY_WRAPPER
  )
FROM Production.ProductSearchView AS p
```

After this, each row contains a JSON document representing a product.

Now vectorize each JSON entry.

```sql
DECLARE @ProductID int, @Json nvarchar(max), @Vector vector(1536)

DECLARE ProductCursor CURSOR FOR
  SELECT ProductID, ProductJson FROM Production.ProductRagIndex ORDER BY ProductID

OPEN ProductCursor
FETCH NEXT FROM ProductCursor INTO @ProductID, @Json

WHILE @@FETCH_STATUS = 0
BEGIN
  EXEC VectorizeText @Json, @Vector OUTPUT

  UPDATE Production.ProductRagIndex
  SET ProductVector = @Vector
  WHERE ProductID = @ProductID

  FETCH NEXT FROM ProductCursor INTO @ProductID, @Json
END

CLOSE ProductCursor
DEALLOCATE ProductCursor
```

Each product is now semantically encoded into a vector. You can verify:

```sql
SELECT TOP 5 * FROM Production.ProductRagIndex
```

---

## Searching the RAG Index by Vector

We’ll create a procedure that takes a natural language question and retrieves the **Top 10 most semantically similar** products from the RAG index.

```sql
CREATE OR ALTER PROCEDURE SearchProductRagIndexJson
  @Question nvarchar(max)
AS
BEGIN
  DECLARE @QuestionVector vector(1536)
  EXEC VectorizeText @Question, @QuestionVector OUTPUT

  DECLARE @Json nvarchar(max) = (
    SELECT TOP 10
      ProductID,
      ProductJson,
      CosineDistance = VECTOR_DISTANCE('cosine', ProductVector, @QuestionVector)
    FROM Production.ProductRagIndex
    WHERE VECTOR_DISTANCE('cosine', ProductVector, @QuestionVector) < 0.5
    ORDER BY CosineDistance
    FOR JSON AUTO
  )

  SELECT JsonResults = @Json
END
```

Test it:

```sql
EXEC SearchProductRagIndexJson 'I want a road bike with good stock levels'
```

You’ll receive a single JSON array representing the most relevant products for the query.

---

## Creating the Chat Completions Stored Procedure

We’ll now define a general-purpose procedure for querying a GPT model via `/chat/completions`. This is nearly identical to the `AskQuestion` procedure in your Recipes lab.

```sql
CREATE OR ALTER PROCEDURE AskProductQuestion
  @Question nvarchar(max),
  @ResponseText nvarchar(max) OUTPUT
AS
BEGIN
  DECLARE @OpenAIEndpoint nvarchar(max) = 'https://lenni-m6wi7gcd-eastus2.cognitiveservices.azure.com/'
  DECLARE @DeploymentName nvarchar(max) = 'gpt-4o'
  DECLARE @Version nvarchar(20) = '2023-05-15'
  DECLARE @Url nvarchar(max) = @OpenAIEndpoint + 'openai/deployments/' + @DeploymentName + '/chat/completions?api-version=' + @Version
  DECLARE @Headers nvarchar(max) = JSON_OBJECT('api-key': '<provided by the instructor>')

  DECLARE @Payload nvarchar(max) = JSON_OBJECT(
    'messages': JSON_ARRAY(
      JSON_OBJECT('role': 'system', 'content': 'You are a product assistant that recommends items from a product catalog.'),
      JSON_OBJECT('role': 'user', 'content': @Question)
    ),
    'temperature': 0.7,
    'max_tokens': 1000
  )

  DECLARE @Response nvarchar(max)
  EXEC sp_invoke_external_rest_endpoint
    @url = @Url,
    @method = 'POST',
    @headers = @Headers,
    @payload = @Payload,
    @response = @Response OUTPUT

  SET @ResponseText = JSON_VALUE(@Response, '$.result.choices[0].message.content')
END
```

---

## Creating the Final Assistant Procedure

This procedure performs the complete RAG flow:

1. Run a vector search against `ProductRagIndex`
2. Combine results into a JSON string
3. Pass question and context into `AskProductQuestion`
4. Return a human-friendly GPT response

```sql
CREATE OR ALTER PROCEDURE AskProductCatalogQuestion @Question nvarchar(max)
AS
BEGIN
  SET NOCOUNT ON

  DECLARE @JsonTable table (JsonResults nvarchar(max))
  INSERT INTO @JsonTable EXEC SearchProductRagIndexJson @Question

  DECLARE @Json nvarchar(max) = (SELECT JsonResults FROM @JsonTable)

  DECLARE @Prompt nvarchar(max) = CONCAT(
    'The user asked: "', @Question, '". ',
    'Based on the following JSON-formatted product catalog data, provide a helpful, natural language response. ',
    'Only include product name, category, price, and description in your summary. Here is the data: ', @Json
  )

  DECLARE @Response nvarchar(max)
  EXEC AskProductQuestion @Prompt, @Response OUTPUT

  PRINT @Response
END
```

Try it:

```sql
EXEC AskProductCatalogQuestion 'What bikes are good for commuting to work?'
```

---

## What You’ve Built

You now have a **full Retrieval-Augmented Generation (RAG)** workflow inside SQL Server 2025 using:

* Real product data from **AdventureWorks2022**
* Embeddings generated by **Azure OpenAI**
* Vector search powered by the **vector** type and `VECTOR_DISTANCE`
* Conversational summaries using **chat completions**

This pattern can be reused for any domain: from product catalogs to service manuals, employee training records, or support tickets.

---

Let me know if you want this turned into a Markdown, Word, or PDF lab—or if you'd like checkpoints, diagrams, or follow-up tasks added.
