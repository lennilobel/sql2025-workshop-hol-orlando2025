# DiskANN Indexing

This lab builds upon the foundational concepts introduced in the previous vector search lab, this time applying those principles to a real-world relational database using AdventureWorks2022. Our goal is to move beyond primitive examples into more scalable and realistic scenarios by using vector search to find semantically similar products based on their names and descriptions.

### Introducing DiskANN

In addition to using SQL Server's native `vector` data type and OpenAI-based embeddings, this lab introduces Microsoft's proprietary **DiskANN** algorithm. This allows us to transition from **KNN (k-nearest neighbor)** search—which examines all rows when used with the `VECTOR_DISTANCE` function—to **ANN (approximate nearest neighbor)** search, which uses a precomputed vector index to achieve far better performance at scale using the `VECTOR_SEARCH` function.

The AdventureWorks2022 database contains product data, including names and descriptions. We will create a new table to store vector embeddings for these products, vectorize their text using Azure OpenAI, and then implement both KNN and ANN search procedures to find similar products based on user queries.

> **Note:** Because we are working with a relatively small database, the performance benefits of ANN will not be readily apparent. The true power of ANN indexing shines when working with extremely large datasets, where it can significantly speed up queries while maintaining high accuracy. Of course, the steps to implement DiskANN indexing are the same regardless of dataset size, and the principles learned here apply equally to larger, more complex systems than AdventureWorks2022.

Here's why DiskANN is so crucial for scalability. When vectorizing and searching across millions of items, computing distance between a query vector and every row (as KNN does) becomes expensive. ANN solves this by **pruning dissimilar vectors early**, speeding up queries while striving to **retain a recall of 1**—meaning the top results would match what you'd get with a full scan.

> **Important:** In its current implementation, once you create a **DiskANN index**, the table becomes **read-only**. To modify data, you must drop and recreate the index. This limitation is expected to be lifted in a future release.

Let's begin.

## Setup

- Connect to SQL Server using SQL Server Management Studio (SSMS).

- Press `CTRL+N` to open a new query window.

In case you skipped the previous lab, you will first need to enable SQL Server's external REST endpoint capabilities so that it can call out to Azure Open AI. If you already completed the previous lab, there is no harm in enabling REST calls once they are already enabled.

```sql
-- Enable REST API support for the system procedure sp_invoke_external_rest_endpoint
USE master
GO

EXEC sp_configure 'external rest endpoint enabled', 1
GO
RECONFIGURE WITH OVERRIDE
GO
```

Now switch to the AdventureWorks2022 database, which contains the product data we will use for vectorization and search:

```sql
USE AdventureWorks2022
GO
```

## Securely Store the Azure OpenAI API Key

We will take a similar approach to calling Azure Open AI as the previous lab, but this time we will store the sensitive Azure OpenAI API key in a database-scoped credential. This allows SQL Server to securely access the Azure OpenAI service without hardcoding the key in our stored procedure, as we did in the previous lab.

To do this, we create a **database master key** and a **database-scoped credential** to securely store the Azure OpenAI API key. We will then be able to reference this credential when invoking the REST API endpoint in our stored procedure, without exposing the actual key.

> **Note:** A database can only have one master key, so if you have already created one in the AdventureWorks2022 database, this code will not try to create another one:

```sql
IF NOT EXISTS (SELECT * FROM sys.symmetric_keys WHERE name = '##MS_DatabaseMasterKey##')
  CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'H@rd2Gue$$P@$$w0rd'

CREATE DATABASE SCOPED CREDENTIAL [https://lenni-openai.openai.azure.com] WITH
  IDENTITY = 'HTTPEndpointHeaders',
  SECRET = '{"api-key": "provided by your instructor"}'

GO
```

Note that the database-scoped credential name must match the URL of your Azure OpenAI endpoint (`https://lenni-openai.openai.azure.com`, in this case). Because a URL contains punctuation characters like the colon and slash, we must surround the name with square brackets. The `IDENTITY` value is a special value that indicates this credential is used for HTTP endpoint headers, and the `SECRET` contains the actual API key in JSON format.

## Create VectorizeText Stored Procedure

In the previous lab, we used Azure OpenAI's `text-embedding-3-large` model to generate vector embeddings from text. That model returned 3072-dimensional vectors, which we needed to compress down to 1536-dimensions in order to accomodate SQL Server's current limit of 1998-dimensions.

In this lab, we will leverage the `text-embedding-ada-002` model, which returns 1536-dimensional vectors, so no compression will be needed.

The following procedure sends input text to Azure OpenAI, retrieves the embedding vector, and returns it as a `vector(1536)` value:

```sql
-- Create a procedure that will use sp_invoke_external_rest_endpoint to interface with an AI model that supports embeddings
CREATE PROCEDURE VectorizeText
  @Text varchar(max),
  @Vector vector(1536) OUTPUT
AS
BEGIN

  -- Azure OpenAI endpoint
  DECLARE @OpenAIEndpoint varchar(max) = 'https://lenni-openai.openai.azure.com/'
  DECLARE @OpenAIDeploymentName varchar(max) = 'lenni-text-embedding-ada-002' -- returns 1536-dimensional vectors
  DECLARE @OpenAIVersion varchar(max) = '2023-05-15'
  DECLARE @Url varchar(max) = CONCAT(@OpenAIEndpoint, 'openai/deployments/', @OpenAIDeploymentName, '/embeddings?api-version=', @OpenAIVersion)

  -- Payload includes the text to be vectorized
  DECLARE @Payload varchar(max) = JSON_OBJECT('input': @Text)

  -- Response and return value
  DECLARE @Response nvarchar(max)
  DECLARE @ReturnValue int

  -- Call Azure OpenAI to vectorize the text
  EXEC @ReturnValue = sp_invoke_external_rest_endpoint
    @url = @Url,
    @method = 'POST',
    @credential = [https://lenni-openai.openai.azure.com],
    @payload = @Payload,
    @response = @Response OUTPUT

  IF @ReturnValue != 0
    THROW 50000, @Response, 1

  DECLARE @VectorJson varchar(max) = JSON_QUERY(@Response, '$.result.data[0].embedding')

  SET @Vector = CONVERT(vector(1536), @VectorJson)

END
GO
```

Also notice how this stored procedure uses the `@credential` parameter to reference the database-scoped credential holding the API key, rather than exposing the API key in the stored procedure code as we did in the previous lab that used the `@headers` parameter to supply the API key. Internally, the `sp_invoke_external_rest_endpoint` procedure will automatically fetch the API key from the database-scoped credential, and include it in the request headers.

Now test the stored procedure to confirm that we are able to successfully vectorize text and retrieve the expected 1536-dimensional vector:

```sql
-- Test the stored procedure
DECLARE @Vector vector(1536)
EXEC VectorizeText 'Sample text to be vectorized', @Vector OUTPUT
SELECT @Vector

GO
```

If everything is set up correctly, you should see the first fragment of the 1536-dimensional vector generated from the sample text.

## Create ProductVector Table

Now we’ll define a new table to store vector embeddings for AdventureWorks products:

```sql
CREATE TABLE Production.ProductVector (
  ProductVectorID       int IDENTITY NOT NULL,
  ProductID			    int NOT NULL,
  ProductDescriptionId  int NOT NULL,
  ProductVector         vector(1536),

  CONSTRAINT PK_ProductVector       PRIMARY KEY CLUSTERED (ProductVectorID),
  CONSTRAINT FK_Product             FOREIGN KEY (ProductID) REFERENCES Production.Product(ProductID),
  CONSTRAINT FK_ProductDescription  FOREIGN KEY (ProductDescriptionID) REFERENCES Production.ProductDescription(ProductDescriptionID),
)
GO
```

Now populate the `Production.ProductVector` table with the product IDs and their corresponding product description IDs. This will allow us to later vectorize the product names and descriptions and store them in the `ProductVector` column:

```sql
INSERT INTO Production.ProductVector (ProductID, ProductDescriptionID)
SELECT
  p.ProductID,
  pd.ProductDescriptionID
FROM
Production.Product                                             AS p
  INNER JOIN Production.ProductModel                           AS pm     ON pm.ProductModelID = p.ProductModelID
  INNER JOIN Production.ProductModelProductDescriptionCulture  AS pmpdc  ON pmpdc.ProductModelID = pm.ProductModelID
  INNER JOIN Production.ProductDescription                     AS pd     ON pd.ProductDescriptionID = pmpdc.ProductDescriptionID
WHERE
  pmpdc.CultureID = 'en'

GO
```

This creates the base table that will later hold vector representations of each product’s name and description. The `WHERE` clause is filtering for the English culture (`en`) to ensure we only include products with descriptions in English. This should result in 294 products.

> **Tip:** In fact, we could omit this filter and include products with descriptions in other languages. In that case, we could then pose natural language queries in those languages, and the vector search would still work. This is a powerful feature of vector search, as it allows for multilingual queries and product descriptions without requiring translation. However, in order to limit the number of products to vectorize in this lab down to 294, we are only including English product descriptions.

Query the table to confirm it has been populated correctly:

```sql
-- Examine the product vector table not yet populated with vectors
SELECT * FROM Production.ProductVector
GO
```

You should see 294 rows, each with `ProductID` and `ProductDescriptionID` values, and a `NULL` value for the `ProductVector` column (as we have not yet populated the vectors).

## Vectorize Products

This section loops through all products and populates their vectors using the `VectorizeText` procedure:

```sql
SET NOCOUNT ON

DECLARE @ProductName			nvarchar(max)
DECLARE @ProductDescription	nvarchar(max)
DECLARE @ProductID				int
DECLARE @ProductDescriptionID	int

DECLARE ProductCursor CURSOR FOR
	SELECT
		p.Name,
		pd.Description,
		p.ProductID,
		pd.ProductDescriptionID
	FROM
		Production.ProductVector				AS pv
		INNER JOIN Production.Product				AS p	ON p.ProductId = pv.ProductId
		INNER JOIN Production.ProductDescription	AS pd	ON pd.ProductDescriptionID = pv.ProductDescriptionID
	ORDER BY
		p.Name

OPEN ProductCursor

	FETCH NEXT FROM ProductCursor INTO @ProductName, @ProductDescription, @ProductID, @ProductDescriptionID

	DECLARE @Counter int = 1

	WHILE @@FETCH_STATUS = 0
	BEGIN

		DECLARE @ProductText nvarchar(max) = (SELECT 'Name: ' || @ProductName || ', Description: ' || @ProductDescription)

		DECLARE @Message nvarchar(max) = @Counter || ' - ' || @ProductText
		RAISERROR(@Message, 0, 1) WITH NOWAIT

		DECLARE @ProductVector vector(1536)
		EXEC VectorizeText @ProductText, @ProductVector OUTPUT

		UPDATE Production.ProductVector
		SET ProductVector = @ProductVector
		WHERE ProductID = @ProductID

		FETCH NEXT FROM ProductCursor INTO @ProductName, @ProductDescription, @ProductID, @ProductDescriptionID
		
		SET @Counter += 1

	END

CLOSE ProductCursor
DEALLOCATE ProductCursor
SET NOCOUNT OFF
GO
```

This cursor constructs a textual description for each product, sends it to OpenAI, and stores the resulting vector.

You can now examine the populated vectors:

```sql
-- Examine the generated product vectors
SELECT
	p.Name,
	pd.Description,
	pv.ProductID,
	pv.ProductDescriptionID,
	pv.ProductVector,
	Dimensions	= VECTORPROPERTY(ProductVector, 'Dimensions'),
	BaseType	= VECTORPROPERTY(ProductVector, 'BaseType'),
	Magnitude	= VECTOR_NORM(ProductVector, 'norm2'),
	Normalized	= VECTOR_NORMALIZE(ProductVector, 'norm2')
FROM
	Production.ProductVector				AS pv
	INNER JOIN Production.Product				AS p	ON p.ProductID = pv.ProductID			
	INNER JOIN Production.ProductDescription	AS pd	ON pd.ProductDescriptionID = pv.ProductDescriptionID

GO
```

---

## 05. Create SearchProductsKNN Stored Procedure

This stored procedure performs a **KNN (exact)** search by comparing the query vector to every row using `VECTOR_DISTANCE()`:

```sql
-- The stored procedure executes a hybrid KNN (exact) vector search using VECTOR_DISTANCE() combined with traditional search
CREATE PROCEDURE SearchProductsKNN
	@QueryText		nvarchar(max),
	@MinStockLevel	smallint		= 100,
	@MaxDistance	decimal(19, 16)	= 0.2,
	@Top			int				= 20
AS
BEGIN

	DECLARE @QueryVector vector(1536)
	EXEC VectorizeText @QueryText, @QueryVector OUTPUT

	;WITH ProductVectorCte AS (
		SELECT TOP (@Top)
			ProductID,
			ProductDescriptionID,
			Distance = VECTOR_DISTANCE('cosine', ProductVector, @QueryVector)
		FROM
			Production.ProductVector
		ORDER BY
			Distance
	)
	SELECT
		ProductName			= p.Name,
		ProductDescription	= pd.Description,
		p.SafetyStockLevel,
		pv.Distance
	FROM
		ProductVectorCte						AS pv
		INNER JOIN Production.Product			AS p	ON p.ProductID = pv.ProductID
		INNER JOIN Production.ProductDescription	AS pd	ON pd.ProductDescriptionID = pv.ProductDescriptionID
	WHERE
		pv.Distance < @MaxDistance AND
		p.SafetyStockLevel >= @MinStockLevel
	ORDER BY    
		pv.Distance

END
GO
```

Test examples:

```sql
EXEC SearchProductsKNN 'Show me the best products for riding on rough ground'
EXEC SearchProductsKNN 'Do you have any yellow or red apples?', @MaxDistance = 0.3
```

This is a **KNN search**—accurate but potentially slow on large datasets.

---

## 06. Create a DiskANN Vector Index

Here we create a **DiskANN** index to enable fast ANN queries:

```sql
CREATE VECTOR INDEX ProductVectorDiskANNIndex
	ON Production.ProductVector (ProductVector)
	WITH (
		METRIC = 'cosine',
		TYPE = 'diskann',
		MAXDOP = 8
	)
GO

SELECT * FROM sys.indexes WHERE name = 'ProductVectorDiskANNIndex'
GO

-- Table is now read-only
UPDATE Production.ProductVector SET ProductVector = NULL
```

Creating the index speeds up ANN queries—but also locks the table from modification. Future versions of SQL Server are expected to lift this restriction.

---

## 07. Create SearchProductsANN Stored Procedure

This stored procedure uses the new `VECTOR_SEARCH()` function to perform **ANN (approximate)** search using the DiskANN index:

```sql
-- The stored procedure executes a hybrid ANN (approximate) vector search using VECTOR_SEARCH() combined with traditional search
CREATE PROCEDURE SearchProductsANN
	@QueryText		nvarchar(max),
	@MinStockLevel	smallint		= 100,
	@MaxDistance	decimal(19, 16)	= 0.2,
	@Top			int				= 20
AS
BEGIN

	DECLARE @QueryVector vector(1536)
	EXEC VectorizeText @QueryText, @QueryVector OUTPUT

	SELECT
		ProductName			= p.Name,
		ProductDescription	= pd.Description,
		p.SafetyStockLevel,
		pvs.Distance
	FROM
		VECTOR_SEARCH(
			TABLE		= Production.ProductVector	AS pvt,
			COLUMN		= ProductVector,
			SIMILAR_TO	= @QueryVector,
			METRIC		= 'cosine',
			TOP_N		= @top
		)											AS pvs
		INNER JOIN Production.ProductVector			AS pv	ON pvt.ProductVectorID = pv.ProductVectorID
		INNER JOIN Production.Product					AS p	ON pv.ProductID = p.ProductID
		INNER JOIN Production.ProductDescription	AS pd	ON pd.ProductDescriptionID = pv.ProductDescriptionID
	WHERE
		pvs.Distance < @MaxDistance AND
		p.SafetyStockLevel >= @MinStockLevel
	ORDER BY
		pvs.distance

END
GO
```

Test examples:

```sql
EXEC SearchProductsANN 'Show me the best products for riding on rough ground'
EXEC SearchProductsANN 'Do you have any yellow or red apples?', @MaxDistance = 0.3
```

### KNN vs. ANN in SQL Server

* `VECTOR_DISTANCE` (used in KNN search) computes the distance between a query vector and every row. This guarantees **exact** results, but becomes **slow** at scale.
* `VECTOR_SEARCH` (used in ANN search with DiskANN) builds an **approximate** index. It returns top matches **much faster**, especially over millions of rows, while still striving to retain **recall = 1**, meaning the top results would match what a full scan would yield.

In this lab, the dataset is too small to measure real performance gains. But on large datasets, the benefits of ANN become clear.

You can validate that the results from ANN and KNN are functionally similar by running:

```sql
EXEC SearchProductsKNN 'Show me the best products for riding on rough ground'
EXEC SearchProductsANN 'Show me the best products for riding on rough ground'
```

---

Congratulations! You’ve now learned how to:

* Store embeddings using real-world product data
* Perform both KNN and ANN vector search
* Use the new DiskANN vector index to enable blazing-fast approximate search

Stay tuned for future versions of SQL Server, where the read-only limitation on vector indexes is expected to be removed, making ANN-based AI search even more powerful and practical in production systems.
