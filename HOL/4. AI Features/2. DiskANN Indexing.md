# DiskANN Indexing

This lab builds upon the foundational concepts introduced in the previous vector search lab, this time applying those principles to a real-world relational database using AdventureWorks2022. Our goal is to move beyond primitive examples into more scalable and realistic scenarios by using vector search to find semantically similar products based on their names and descriptions.

In addition to using SQL Server's native `vector` data type and OpenAI-based embeddings, this lab introduces Microsoft's proprietary **DiskANN** algorithm. This allows us to transition from **KNN (k-nearest neighbor)** search—which examines all rows when used with the `VECTOR_DISTANCE` function—to **ANN (approximate nearest neighbor)** search, which uses a precomputed vector index to achieve far better performance at scale using the `VECTOR_SEARCH` function.

The AdventureWorks2022 database contains a wealth of product data, including names and descriptions. We will create a new table to store vector embeddings for these products, vectorize their text using Azure OpenAI, and then implement both KNN and ANN search procedures to find similar products based on user queries.

Because we are working with a relatively small database, the performance benefits of ANN will not be readily apparent. The true power of ANN indexing shines when working with extremely large datasets, where it can significantly speed up queries while maintaining high accuracy. Of course, the steps to implement DiskANN indexing are the same regardless of dataset size, and the principles learned here apply equally to larger, more complex systems than AdventureWorks2022.

Here's why DiskANN is so crucial for scalability. When vectorizing and searching across millions of items, computing distance between a query vector and every row (as KNN does) becomes expensive. ANN solves this by **pruning dissimilar vectors early**, speeding up queries while striving to **retain a recall of 1**—meaning the top results would match what you'd get with a full scan.

> **Note:** In its current implementation, once you create a **DiskANN index**, the table becomes **read-only**. To modify data, you must drop and recreate the index. This limitation is expected to be lifted in a future release.

Let's begin.

---

## 01. Setup

We begin by enabling the required capabilities and creating credentials to allow SQL Server to call Azure OpenAI:

```sql
-- Enable REST API support for the system procedure sp_invoke_external_rest_endpoint
USE master
GO

EXEC sp_configure 'external rest endpoint enabled', 1
GO
RECONFIGURE WITH OVERRIDE
GO

-- Enable vector index and search for CTP builds
DBCC TRACEON (466, 13981, -1)
GO

-- Create database credentials to store API key
USE AdventureWorks2022
GO

CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'H@rd2Gue$$P@$$w0rd'

CREATE DATABASE SCOPED CREDENTIAL [https://lenni-openai.openai.azure.com] WITH
	IDENTITY = 'HTTPEndpointHeaders',
	SECRET = '{"api-key": "1e981882b329481ebe4b2bfa261f8dce"}'
```

This enables SQL Server's external REST call functionality, activates the experimental vector index support (if using a CTP build), and stores your API key securely.

---

## 02. Create VectorizeText Stored Procedure

The following procedure sends input text to Azure OpenAI, retrieves the embedding vector, and returns it as a `vector(1536)` value:

```sql
-- Create a procedure that will use sp_invoke_external_rest_endpoint to interface with an AI model that supports embeddings
CREATE PROCEDURE VectorizeText
	@Text varchar(max),
	@Vector vector(1536) OUTPUT
AS
BEGIN

	DECLARE @OpenAIEndpoint varchar(max) = 'https://lenni-openai.openai.azure.com/'	-- Your Azure OpenAI endpoint
	DECLARE @OpenAIDeploymentName varchar(max) = 'lenni-text-embedding-ada-002'		-- The 'Text Embedding ADA 002' model yields 1536 components (floating point values) per vector

	DECLARE @Url varchar(max) = CONCAT(@OpenAIEndpoint, 'openai/deployments/', @OpenAIDeploymentName, '/embeddings?api-version=2023-03-15-preview')	-- ?api-version=2024-02-01
	DECLARE @Payload varchar(max) = JSON_OBJECT('input': @Text)
	DECLARE @Response nvarchar(max)
	DECLARE @ReturnValue int

	-- Call Azure OpenAI to vectorize the text
	EXEC @ReturnValue = sp_invoke_external_rest_endpoint
		@url = @Url,
		@method = 'POST',
        @credential = [https://lenni-openai.openai.azure.com],
		@payload = @Payload,
		@response = @Response OUTPUT

	IF @ReturnValue != 0
		THROW 50000, @Response, 1

	DECLARE @VectorJson varchar(max) = JSON_QUERY(@Response, '$.result.data[0].embedding')

	SET @Vector = CONVERT(vector(1536), @VectorJson)

END
GO
```

This code uses Azure OpenAI's `text-embedding-ada-002` model, which returns 1536-dimensional vectors. The procedure is tested immediately after creation:

```sql
-- Test the stored procedure
DECLARE @Vector vector(1536)
EXEC VectorizeText 'Sample text to be vectorized', @Vector OUTPUT

SELECT
	Vector		= @Vector,
	Dimensions	= VECTORPROPERTY(@Vector, 'Dimensions'),
	BaseType	= VECTORPROPERTY(@Vector, 'BaseType'),
	Magnitude	= VECTOR_NORM(@Vector, 'norm2'),
	Normalized	= VECTOR_NORMALIZE(@Vector, 'norm2')
```

This test confirms that the embedding was received, sized correctly, and normalized.

---

## 03. Create ProductVector Table

Now we’ll define a new table to store vector embeddings for AdventureWorks products:

```sql
CREATE TABLE Production.ProductVector (
	ProductVectorID			int IDENTITY NOT NULL,
	ProductID				int NOT NULL,
	ProductDescriptionId	int NOT NULL,
	ProductVector			vector(1536),

	CONSTRAINT PK_ProductVector			PRIMARY KEY CLUSTERED (ProductVectorID),
	CONSTRAINT FK_Product				FOREIGN KEY (ProductID) REFERENCES Production.Product(ProductID),
	CONSTRAINT FK_ProductDescription	FOREIGN KEY (ProductDescriptionID) REFERENCES Production.ProductDescription(ProductDescriptionID),
)
GO

INSERT INTO Production.ProductVector (ProductID, ProductDescriptionID)
SELECT
	p.ProductID,
	pd.ProductDescriptionID
FROM
	Production.Product								AS p
	INNER JOIN Production.ProductModel						AS pm		ON pm.ProductModelID = p.ProductModelID
	INNER JOIN Production.ProductModelProductDescriptionCulture	AS pmpdc	ON pmpdc.ProductModelID = pm.ProductModelID
	INNER JOIN Production.ProductDescription				AS pd		ON pd.ProductDescriptionID = pmpdc.ProductDescriptionID
WHERE
	pmpdc.CultureID = 'en'

-- Examine the product vector table not yet populated with vectors
SELECT * FROM Production.ProductVector
```

This creates the base table that will later hold vector representations of each product’s name and description.

---

## 04. Vectorize Products

This section loops through all products and populates their vectors using the `VectorizeText` procedure:

```sql
SET NOCOUNT ON

DECLARE @ProductName			nvarchar(max)
DECLARE @ProductDescription	nvarchar(max)
DECLARE @ProductID				int
DECLARE @ProductDescriptionID	int

DECLARE ProductCursor CURSOR FOR
	SELECT
		p.Name,
		pd.Description,
		p.ProductID,
		pd.ProductDescriptionID
	FROM
		Production.ProductVector				AS pv
		INNER JOIN Production.Product				AS p	ON p.ProductId = pv.ProductId
		INNER JOIN Production.ProductDescription	AS pd	ON pd.ProductDescriptionID = pv.ProductDescriptionID
	ORDER BY
		p.Name

OPEN ProductCursor

	FETCH NEXT FROM ProductCursor INTO @ProductName, @ProductDescription, @ProductID, @ProductDescriptionID

	DECLARE @Counter int = 1

	WHILE @@FETCH_STATUS = 0
	BEGIN

		DECLARE @ProductText nvarchar(max) = (SELECT 'Name: ' || @ProductName || ', Description: ' || @ProductDescription)

		DECLARE @Message nvarchar(max) = @Counter || ' - ' || @ProductText
		RAISERROR(@Message, 0, 1) WITH NOWAIT

		DECLARE @ProductVector vector(1536)
		EXEC VectorizeText @ProductText, @ProductVector OUTPUT

		UPDATE Production.ProductVector
		SET ProductVector = @ProductVector
		WHERE ProductID = @ProductID

		FETCH NEXT FROM ProductCursor INTO @ProductName, @ProductDescription, @ProductID, @ProductDescriptionID
		
		SET @Counter += 1

	END

CLOSE ProductCursor
DEALLOCATE ProductCursor
SET NOCOUNT OFF
GO
```

This cursor constructs a textual description for each product, sends it to OpenAI, and stores the resulting vector.

You can now examine the populated vectors:

```sql
-- Examine the generated product vectors
SELECT
	p.Name,
	pd.Description,
	pv.ProductID,
	pv.ProductDescriptionID,
	pv.ProductVector,
	Dimensions	= VECTORPROPERTY(ProductVector, 'Dimensions'),
	BaseType	= VECTORPROPERTY(ProductVector, 'BaseType'),
	Magnitude	= VECTOR_NORM(ProductVector, 'norm2'),
	Normalized	= VECTOR_NORMALIZE(ProductVector, 'norm2')
FROM
	Production.ProductVector				AS pv
	INNER JOIN Production.Product				AS p	ON p.ProductID = pv.ProductID			
	INNER JOIN Production.ProductDescription	AS pd	ON pd.ProductDescriptionID = pv.ProductDescriptionID
```

---

## 05. Create SearchProductsKNN Stored Procedure

This stored procedure performs a **KNN (exact)** search by comparing the query vector to every row using `VECTOR_DISTANCE()`:

```sql
-- The stored procedure executes a hybrid KNN (exact) vector search using VECTOR_DISTANCE() combined with traditional search
CREATE PROCEDURE SearchProductsKNN
	@QueryText		nvarchar(max),
	@MinStockLevel	smallint		= 100,
	@MaxDistance	decimal(19, 16)	= 0.2,
	@Top			int				= 20
AS
BEGIN

	DECLARE @QueryVector vector(1536)
	EXEC VectorizeText @QueryText, @QueryVector OUTPUT

	;WITH ProductVectorCte AS (
		SELECT TOP (@Top)
			ProductID,
			ProductDescriptionID,
			Distance = VECTOR_DISTANCE('cosine', ProductVector, @QueryVector)
		FROM
			Production.ProductVector
		ORDER BY
			Distance
	)
	SELECT
		ProductName			= p.Name,
		ProductDescription	= pd.Description,
		p.SafetyStockLevel,
		pv.Distance
	FROM
		ProductVectorCte						AS pv
		INNER JOIN Production.Product			AS p	ON p.ProductID = pv.ProductID
		INNER JOIN Production.ProductDescription	AS pd	ON pd.ProductDescriptionID = pv.ProductDescriptionID
	WHERE
		pv.Distance < @MaxDistance AND
		p.SafetyStockLevel >= @MinStockLevel
	ORDER BY    
		pv.Distance

END
GO
```

Test examples:

```sql
EXEC SearchProductsKNN 'Show me the best products for riding on rough ground'
EXEC SearchProductsKNN 'Do you have any yellow or red apples?', @MaxDistance = 0.3
```

This is a **KNN search**—accurate but potentially slow on large datasets.

---

## 06. Create a DiskANN Vector Index

Here we create a **DiskANN** index to enable fast ANN queries:

```sql
CREATE VECTOR INDEX ProductVectorDiskANNIndex
	ON Production.ProductVector (ProductVector)
	WITH (
		METRIC = 'cosine',
		TYPE = 'diskann',
		MAXDOP = 8
	)
GO

SELECT * FROM sys.indexes WHERE name = 'ProductVectorDiskANNIndex'
GO

-- Table is now read-only
UPDATE Production.ProductVector SET ProductVector = NULL
```

Creating the index speeds up ANN queries—but also locks the table from modification. Future versions of SQL Server are expected to lift this restriction.

---

## 07. Create SearchProductsANN Stored Procedure

This stored procedure uses the new `VECTOR_SEARCH()` function to perform **ANN (approximate)** search using the DiskANN index:

```sql
-- The stored procedure executes a hybrid ANN (approximate) vector search using VECTOR_SEARCH() combined with traditional search
CREATE PROCEDURE SearchProductsANN
	@QueryText		nvarchar(max),
	@MinStockLevel	smallint		= 100,
	@MaxDistance	decimal(19, 16)	= 0.2,
	@Top			int				= 20
AS
BEGIN

	DECLARE @QueryVector vector(1536)
	EXEC VectorizeText @QueryText, @QueryVector OUTPUT

	SELECT
		ProductName			= p.Name,
		ProductDescription	= pd.Description,
		p.SafetyStockLevel,
		pvs.Distance
	FROM
		VECTOR_SEARCH(
			TABLE		= Production.ProductVector	AS pvt,
			COLUMN		= ProductVector,
			SIMILAR_TO	= @QueryVector,
			METRIC		= 'cosine',
			TOP_N		= @top
		)											AS pvs
		INNER JOIN Production.ProductVector			AS pv	ON pvt.ProductVectorID = pv.ProductVectorID
		INNER JOIN Production.Product					AS p	ON pv.ProductID = p.ProductID
		INNER JOIN Production.ProductDescription	AS pd	ON pd.ProductDescriptionID = pv.ProductDescriptionID
	WHERE
		pvs.Distance < @MaxDistance AND
		p.SafetyStockLevel >= @MinStockLevel
	ORDER BY
		pvs.distance

END
GO
```

Test examples:

```sql
EXEC SearchProductsANN 'Show me the best products for riding on rough ground'
EXEC SearchProductsANN 'Do you have any yellow or red apples?', @MaxDistance = 0.3
```

### KNN vs. ANN in SQL Server

* `VECTOR_DISTANCE` (used in KNN search) computes the distance between a query vector and every row. This guarantees **exact** results, but becomes **slow** at scale.
* `VECTOR_SEARCH` (used in ANN search with DiskANN) builds an **approximate** index. It returns top matches **much faster**, especially over millions of rows, while still striving to retain **recall = 1**, meaning the top results would match what a full scan would yield.

In this lab, the dataset is too small to measure real performance gains. But on large datasets, the benefits of ANN become clear.

You can validate that the results from ANN and KNN are functionally similar by running:

```sql
EXEC SearchProductsKNN 'Show me the best products for riding on rough ground'
EXEC SearchProductsANN 'Show me the best products for riding on rough ground'
```

---

Congratulations! You’ve now learned how to:

* Store embeddings using real-world product data
* Perform both KNN and ANN vector search
* Use the new DiskANN vector index to enable blazing-fast approximate search

Stay tuned for future versions of SQL Server, where the read-only limitation on vector indexes is expected to be removed, making ANN-based AI search even more powerful and practical in production systems.
