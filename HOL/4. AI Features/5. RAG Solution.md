# RAG Solution

```sql
USE AdventureWorks2022
GO

CREATE OR ALTER PROCEDURE SearchProductsReturningJson
  @QueryText      nvarchar(max),
  @JsonResults    nvarchar(max) OUTPUT
AS
BEGIN

  DECLARE @Results TABLE (
    ProductName         nvarchar(max),
    ProductDescription  nvarchar(max),
    SafetyStockLevel    smallint,
    Distance            decimal(19, 16)
  )

  INSERT INTO @Results
  EXEC SearchProductsANN
    @QueryText     = @QueryText,
    @MinStockLevel = 100,
    @MaxDistance   = .2,
    @Top           = 20

  SELECT @JsonResults = (
    SELECT
      ProductName,
      ProductDescription
    FROM
      @Results
    FOR JSON AUTO
  )

END
GO
```

```sql
DECLARE @JsonResults nvarchar(max)
EXEC SearchProductsReturningJson 'Show me the best products for riding on rough ground', @JsonResults OUTPUT
SELECT @JsonResults
GO
```


```sql
-- Create a stored procedure that can call Azure OpenAI to chat using a completion model
CREATE OR ALTER PROCEDURE AskProductQuestion
  @ProductQuestion varchar(max),
  @JsonResults varchar(max),
  @ProductAnswer varchar(max) OUTPUT
AS
BEGIN

  DECLARE @SystemPrompt varchar(max) = '
    You are an assistant that helps people find bicycle and related products from vectorized
    product descriptions in the AdventureWorks2022 database. Your demeanor is upbeat and
    friendly.
    
    A vector search returns product results similar to a natural language query posed by the user.
    Your job is to take the raw results of the vector search and generate a natural language
    response that starts with a sentence or two related to the user''s question, followed by
    the details of each product in the search results.

    Do not include markdown syntax, such as double asterisks or pound signs. Do not include emojis either.

    Include all the products returned by the vector search, even those that don''t relate to the user''s
    question. However, call out those products that don''t relate to the user''s question. If there are no
    product results, apologize and explain that there are no products to suggest.
    
    If the user asks a question unrelated to products, try to answer it anyway, but stress that your primary
    purpose is to help with bicycles and related products in the database.
  '

  DECLARE @UserPrompt varchar(max) = CONCAT('
    The user asked "', @ProductQuestion, '", and the vector search returned the following products: ', @JsonResults, '
  ')

  DECLARE @OpenAIEndpoint varchar(max) = 'https://lenni-openai.openai.azure.com/'  -- Your Azure OpenAI endpoint
  DECLARE @OpenAIDeploymentName varchar(max) = 'lenni-gpt-4o'            -- The 'GPT 4o' chat completion model

  DECLARE @Url varchar(max) = CONCAT(@OpenAIEndpoint, 'openai/deployments/', @OpenAIDeploymentName, '/chat/completions?api-version=2023-05-15')
  DECLARE @Payload varchar(max) = JSON_OBJECT(
    'messages': JSON_ARRAY(
      JSON_OBJECT('role': 'system', 'content': @SystemPrompt),
      JSON_OBJECT('role': 'user', 'content': @UserPrompt)
    ),
    'max_tokens': 1000,         -- Max number of tokens for the response; the more tokens you specify (spend), the more verbose the response
    'temperature': 1.0,         -- Range is 0.0 to 2.0; controls "apparent creativity"; higher = more random, lower = more deterministic
    'frequency_penalty': 0.0,   -- Range is -2.0 to 2.0; controls likelihood of repeating words; higher = less likely, lower = more likely
    'presence_penalty': 0.0,    -- Range is -2.0 to 2.0; controls likelihood of introducing new topics; higher = more likely, lower = less likely
    'top_p': 0.95               -- Range is 0.0 to 2.0; aka "Top P sampling"; temperature alternative; controls diversity of responses (1.0 is full random, lower values limit randomness)
  )

  DECLARE @Response nvarchar(max)
  DECLARE @ReturnValue int

  -- Call Azure OpenAI to get a chat completion response
  EXEC @ReturnValue = sp_invoke_external_rest_endpoint
    @url = @Url,
    @method = 'POST',
    @credential = [https://lenni-openai.openai.azure.com],
    @payload = @Payload,
    @response = @Response OUTPUT

  IF @ReturnValue != 0
    THROW 50000, @Response, 1

  SET @ProductAnswer = JSON_VALUE(@Response, '$.result.choices[0].message.content')

END
GO

DECLARE @ProductAnswer varchar(max)
EXEC AskProductQuestion 'What is the capital of France?', '[]', @ProductAnswer OUTPUT
PRINT @ProductAnswer 
GO
```

```sql
CREATE OR ALTER PROCEDURE ProductAssistant @ProductQuestion nvarchar(max)
AS
BEGIN

  SET NOCOUNT ON

  -- Run a vector search and capture the results as JSON
  DECLARE @JsonResults nvarchar(max)
  EXEC SearchProductsReturningJson @ProductQuestion, @JsonResults OUTPUT

  -- Call the GPT model to generate the natural language response from the raw JSON results
  DECLARE @ProductAnswer nvarchar(max)
  EXEC AskProductQuestion @ProductQuestion, @JsonResults, @ProductAnswer OUTPUT
  PRINT @ProductAnswer

END
GO
```

```sql
EXEC ProductAssistant 'Show me the best products for riding on rough ground'
EXEC ProductAssistant 'Recommend a bike that is good for riding around the city'
EXEC ProductAssistant 'Looking for budget-friendly gear for beginners just getting into cycling'
EXEC ProductAssistant 'What''s best for long-distance rides with storage for travel gear?'
EXEC ProductAssistant 'Do you have any yellow or red bikes?'
EXEC ProductAssistant 'Do you have any yellow or red apples?'
```


---

---



This lab builds directly on the previous labs. You will now implement a complete **Retrieval-Augmented Generation (RAG)** solution using product data from the **AdventureWorks2022** database.

This introduces a new capability: turning search results into **natural language responses** using a **chat completions model**. You will retrieve relevant data using vector search (as before), and then—rather than simply displaying those raw database results—pass those results into a GPT model to create a conversational, human-friendly response.

This is the same architecture used by AI copilots, assistants, and RAG-based applications—now implemented directly inside SQL Server 2025.

---

## Preparing the Unified Product View

To support rich vectorization and natural language generation, we need to **flatten** our relational schema into a single row per product. This denormalized view will include:

* Product name and description
* Product category and model name
* Color, size, and price
* Safety stock and reorder levels

This view will serve two purposes:

1. **Embedding source** for vector generation
2. **Context payload** for GPT input

```sql
CREATE OR ALTER VIEW ProductSearchView AS
SELECT 
  p.ProductID,
  ProductName = p.Name,
  ProductDescription = pd.Description,
  CategoryName = pc.Name,
  ModelName = pm.Name,
  p.Color,
  p.Size,
  p.ListPrice,
  p.SafetyStockLevel,
  p.ReorderPoint
FROM Production.Product p
JOIN Production.ProductModel pm ON p.ProductModelID = pm.ProductModelID
JOIN Production.ProductModelProductDescriptionCulture pmpdc ON pmpdc.ProductModelID = pm.ProductModelID
JOIN Production.ProductDescription pd ON pd.ProductDescriptionID = pmpdc.ProductDescriptionID
JOIN Production.ProductSubcategory psc ON p.ProductSubcategoryID = psc.ProductSubcategoryID
JOIN Production.ProductCategory pc ON psc.ProductCategoryID = pc.ProductCategoryID
WHERE pmpdc.CultureID = 'en'
```

Query this view to see the full product context flattened into a single row per product:

```sql
SELECT TOP 5 * FROM ProductSearchView
```

---

## Storing Product Vectors

To support RAG, we need a table that stores both the full JSON for each product and its associated vector.

```sql
CREATE TABLE Production.ProductRagIndex (
  ProductRagIndexID int IDENTITY PRIMARY KEY,
  ProductID int NOT NULL,
  ProductJson nvarchar(max),
  ProductVector vector(1536),
  FOREIGN KEY (ProductID) REFERENCES Production.Product(ProductID)
)
```

Each row in this table represents a searchable document in our RAG index.

---

## Populating the ProductRagIndex Table

We will transform each row in `ProductSearchView` into a JSON document and vectorize it for similarity search. This preserves both structure and meaning.

```sql
TRUNCATE TABLE Production.ProductRagIndex

INSERT INTO Production.ProductRagIndex (ProductID, ProductJson)
SELECT 
  ProductID,
  (
    SELECT * 
    FROM ProductSearchView AS v 
    WHERE v.ProductID = p.ProductID 
    FOR JSON AUTO, WITHOUT_ARRAY_WRAPPER
  )
FROM Production.ProductSearchView AS p
```

After this, each row contains a JSON document representing a product.

Now vectorize each JSON entry.

```sql
DECLARE @ProductID int, @Json nvarchar(max), @Vector vector(1536)

DECLARE ProductCursor CURSOR FOR
  SELECT ProductID, ProductJson FROM Production.ProductRagIndex ORDER BY ProductID

OPEN ProductCursor
FETCH NEXT FROM ProductCursor INTO @ProductID, @Json

WHILE @@FETCH_STATUS = 0
BEGIN
  EXEC VectorizeText @Json, @Vector OUTPUT

  UPDATE Production.ProductRagIndex
  SET ProductVector = @Vector
  WHERE ProductID = @ProductID

  FETCH NEXT FROM ProductCursor INTO @ProductID, @Json
END

CLOSE ProductCursor
DEALLOCATE ProductCursor
```

Each product is now semantically encoded into a vector. You can verify:

```sql
SELECT TOP 5 * FROM Production.ProductRagIndex
```

---

## Searching the RAG Index by Vector

We’ll create a procedure that takes a natural language question and retrieves the **Top 10 most semantically similar** products from the RAG index.

```sql
CREATE OR ALTER PROCEDURE SearchProductRagIndexJson
  @Question nvarchar(max)
AS
BEGIN
  DECLARE @QuestionVector vector(1536)
  EXEC VectorizeText @Question, @QuestionVector OUTPUT

  DECLARE @Json nvarchar(max) = (
    SELECT TOP 10
      ProductID,
      ProductJson,
      CosineDistance = VECTOR_DISTANCE('cosine', ProductVector, @QuestionVector)
    FROM Production.ProductRagIndex
    WHERE VECTOR_DISTANCE('cosine', ProductVector, @QuestionVector) < 0.5
    ORDER BY CosineDistance
    FOR JSON AUTO
  )

  SELECT JsonResults = @Json
END
```

Test it:

```sql
EXEC SearchProductRagIndexJson 'I want a road bike with good stock levels'
```

You’ll receive a single JSON array representing the most relevant products for the query.

---

## Creating the Chat Completions Stored Procedure

We’ll now define a general-purpose procedure for querying a GPT model via `/chat/completions`. This is nearly identical to the `AskQuestion` procedure in your Recipes lab.

```sql
CREATE OR ALTER PROCEDURE AskProductQuestion
  @Question nvarchar(max),
  @ResponseText nvarchar(max) OUTPUT
AS
BEGIN
  DECLARE @OpenAIEndpoint nvarchar(max) = 'https://lenni-m6wi7gcd-eastus2.cognitiveservices.azure.com/'
  DECLARE @DeploymentName nvarchar(max) = 'gpt-4o'
  DECLARE @Version nvarchar(20) = '2023-05-15'
  DECLARE @Url nvarchar(max) = @OpenAIEndpoint + 'openai/deployments/' + @DeploymentName + '/chat/completions?api-version=' + @Version
  DECLARE @Headers nvarchar(max) = JSON_OBJECT('api-key': '<provided by the instructor>')

  DECLARE @Payload nvarchar(max) = JSON_OBJECT(
    'messages': JSON_ARRAY(
      JSON_OBJECT('role': 'system', 'content': 'You are a product assistant that recommends items from a product catalog.'),
      JSON_OBJECT('role': 'user', 'content': @Question)
    ),
    'temperature': 0.7,
    'max_tokens': 1000
  )

  DECLARE @Response nvarchar(max)
  EXEC sp_invoke_external_rest_endpoint
    @url = @Url,
    @method = 'POST',
    @headers = @Headers,
    @payload = @Payload,
    @response = @Response OUTPUT

  SET @ResponseText = JSON_VALUE(@Response, '$.result.choices[0].message.content')
END
```

---

## Creating the Final Assistant Procedure

This procedure performs the complete RAG flow:

1. Run a vector search against `ProductRagIndex`
2. Combine results into a JSON string
3. Pass question and context into `AskProductQuestion`
4. Return a human-friendly GPT response

```sql
CREATE OR ALTER PROCEDURE AskProductCatalogQuestion @Question nvarchar(max)
AS
BEGIN
  SET NOCOUNT ON

  DECLARE @JsonTable table (JsonResults nvarchar(max))
  INSERT INTO @JsonTable EXEC SearchProductRagIndexJson @Question

  DECLARE @Json nvarchar(max) = (SELECT JsonResults FROM @JsonTable)

  DECLARE @Prompt nvarchar(max) = CONCAT(
    'The user asked: "', @Question, '". ',
    'Based on the following JSON-formatted product catalog data, provide a helpful, natural language response. ',
    'Only include product name, category, price, and description in your summary. Here is the data: ', @Json
  )

  DECLARE @Response nvarchar(max)
  EXEC AskProductQuestion @Prompt, @Response OUTPUT

  PRINT @Response
END
```

Try it:

```sql
EXEC AskProductCatalogQuestion 'What bikes are good for commuting to work?'
```

---

## What You’ve Built

You now have a **full Retrieval-Augmented Generation (RAG)** workflow inside SQL Server 2025 using:

* Real product data from **AdventureWorks2022**
* Embeddings generated by **Azure OpenAI**
* Vector search powered by the **vector** type and `VECTOR_DISTANCE`
* Conversational summaries using **chat completions**

This pattern can be reused for any domain: from product catalogs to service manuals, employee training records, or support tickets.

---

Let me know if you want this turned into a Markdown, Word, or PDF lab—or if you'd like checkpoints, diagrams, or follow-up tasks added.
