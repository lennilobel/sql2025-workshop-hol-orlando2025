# Vector Search with DiskANN and External AI Models

This lab extends your knowledge of vector search by working with real product data from the **AdventureWorks2022** sample database. You’ll explore the advanced AI integration capabilities in **SQL Server 2025** and **Azure SQL Database**, including:

* The new `vector` data type for storing AI-generated embeddings
* High-performance **DiskANN indexing** and the `VECTOR_SEARCH` function
* Secure AI access through **external models** using `CREATE EXTERNAL MODEL`

Where the previous lab used a simple Movie table, this lab introduces a richer schema, a real-world use case, and a production-grade vector indexing strategy.

---

## Enabling Vector and AI Support

To use the new features in SQL Server 2025 preview builds, including `sp_invoke_external_rest_endpoint` and DiskANN indexing, you must enable them explicitly. This is typically done in test environments or CTP builds.

```sql
USE master
GO

EXEC sp_configure 'external rest endpoint enabled', 1
GO
RECONFIGURE WITH OVERRIDE
GO

DBCC TRACEON (466, 13981, -1)
GO
```

This enables REST API calls from T-SQL and activates internal vector indexing trace flags required for preview environments.

---

## Creating a Credential for OpenAI Access

We’ll use a **database-scoped credential** to securely store the Azure OpenAI API key. This credential can be reused in both stored procedures and external models, and avoids embedding keys directly in code.

```sql
USE AdventureWorks2022
GO

CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'H@rd2Gue$$P@$$w0rd'

CREATE DATABASE SCOPED CREDENTIAL [https://lenni-openai.openai.azure.com]
WITH IDENTITY = 'HTTPEndpointHeaders',
SECRET = '{"api-key": "your-api-key-here"}'
```

Replace the placeholder API key with the value provided for your lab environment. The identity is fixed and must match what the external model or REST endpoint expects.

---

## Creating a Stored Procedure to Vectorize Text

To generate vector embeddings from product descriptions, we’ll define a `VectorizeText` stored procedure that calls Azure OpenAI using `sp_invoke_external_rest_endpoint`.

```sql
CREATE PROCEDURE VectorizeText
  @Text varchar(max),
  @Vector vector(1536) OUTPUT
AS
BEGIN
  DECLARE @Url varchar(max) =
    'https://lenni-openai.openai.azure.com/openai/deployments/lenni-text-embedding-ada-002/embeddings?api-version=2023-03-15-preview'

  DECLARE @Payload varchar(max) = JSON_OBJECT('input': @Text)
  DECLARE @Response nvarchar(max)

  EXEC sp_invoke_external_rest_endpoint
    @url = @Url,
    @method = 'POST',
    @credential = [https://lenni-openai.openai.azure.com],
    @payload = @Payload,
    @response = @Response OUTPUT

  IF @@ERROR != 0
    THROW 50000, @Response, 1

  DECLARE @VectorJson varchar(max) = JSON_QUERY(@Response, '$.result.data[0].embedding')
  SET @Vector = CONVERT(vector(1536), @VectorJson)
END
```

This procedure accepts any input string and returns a 1536-dimensional vector using OpenAI’s `text-embedding-ada-002` model.

---

## Creating and Populating the ProductVector Table

We’ll now define a new table named `ProductVector` to store product descriptions along with their vector embeddings.

```sql
CREATE TABLE Production.ProductVector (
  ProductVectorID int IDENTITY PRIMARY KEY,
  ProductID int NOT NULL,
  ProductDescriptionID int NOT NULL,
  ProductVector vector(1536),
  FOREIGN KEY (ProductID) REFERENCES Production.Product(ProductID),
  FOREIGN KEY (ProductDescriptionID) REFERENCES Production.ProductDescription(ProductDescriptionID)
)
```

This table maps AdventureWorks products and their descriptions to a corresponding AI-generated vector representation.

Next, we seed the table with data from the existing `Product`, `ProductModel`, and `ProductDescription` tables. We’ll only include English descriptions to simplify the dataset.

```sql
INSERT INTO Production.ProductVector (ProductID, ProductDescriptionID)
SELECT p.ProductID, pd.ProductDescriptionID
FROM Production.Product p
JOIN Production.ProductModel pm ON p.ProductModelID = pm.ProductModelID
JOIN Production.ProductModelProductDescriptionCulture pmpdc ON pmpdc.ProductModelID = pm.ProductModelID
JOIN Production.ProductDescription pd ON pd.ProductDescriptionID = pmpdc.ProductDescriptionID
WHERE pmpdc.CultureID = 'en'
```

---

## Generating Embeddings for Each Product

Now we’ll loop through each row in the `ProductVector` table and generate a vector using the `VectorizeText` procedure. The vector is based on a combined string of the product name and its description.

```sql
DECLARE ProductCursor CURSOR FOR
SELECT p.Name, pd.Description, p.ProductID, pd.ProductDescriptionID
FROM Production.ProductVector pv
JOIN Production.Product p ON p.ProductID = pv.ProductID
JOIN Production.ProductDescription pd ON pd.ProductDescriptionID = pv.ProductDescriptionID
ORDER BY p.Name

OPEN ProductCursor

DECLARE @Name nvarchar(max), @Desc nvarchar(max), @ProductID int, @DescID int, @Vector vector(1536)

FETCH NEXT FROM ProductCursor INTO @Name, @Desc, @ProductID, @DescID

WHILE @@FETCH_STATUS = 0
BEGIN
  DECLARE @Text nvarchar(max) = 'Name: ' + @Name + ', Description: ' + @Desc
  EXEC VectorizeText @Text, @Vector OUTPUT
  UPDATE Production.ProductVector SET ProductVector = @Vector WHERE ProductID = @ProductID
  FETCH NEXT FROM ProductCursor INTO @Name, @Desc, @ProductID, @DescID
END

CLOSE ProductCursor
DEALLOCATE ProductCursor
```

This process will populate the `ProductVector` column with real AI-generated embeddings.

---

## Performing Exact Vector Search with VECTOR\_DISTANCE

With the data vectorized, we can now define a stored procedure that searches using **exact cosine similarity**. This procedure finds the top `N` products most semantically similar to a query.

```sql
CREATE PROCEDURE SearchProductsKNN
  @QueryText nvarchar(max),
  @Top int = 10
AS
BEGIN
  DECLARE @Vector vector(1536)
  EXEC VectorizeText @QueryText, @Vector OUTPUT

  SELECT TOP (@Top)
    p.Name,
    pd.Description,
    Distance = VECTOR_DISTANCE('cosine', pv.ProductVector, @Vector)
  FROM Production.ProductVector pv
  JOIN Production.Product p ON p.ProductID = pv.ProductID
  JOIN Production.ProductDescription pd ON pd.ProductDescriptionID = pv.ProductDescriptionID
  ORDER BY Distance
END
```

Use this procedure for scenarios where **accuracy is more important than speed**.

---

## Creating a DiskANN Index for Approximate Vector Search

To improve performance, we’ll now create a **DiskANN vector index** over the `ProductVector` column. This enables `VECTOR_SEARCH`, which performs high-speed ANN search.

```sql
CREATE VECTOR INDEX ProductVectorDiskANNIndex
ON Production.ProductVector (ProductVector)
WITH (METRIC = 'cosine', TYPE = 'diskann', MAXDOP = 4)
```

Note: once this index is created, the table becomes read-only. You can still perform SELECT queries and run ANN searches, but cannot modify vector values until the index is dropped.

---

## Searching with VECTOR\_SEARCH and DiskANN

This procedure performs **approximate similarity search** using the `VECTOR_SEARCH` table function.

```sql
CREATE PROCEDURE SearchProductsANN
  @QueryText nvarchar(max),
  @Top int = 10
AS
BEGIN
  DECLARE @Vector vector(1536)
  EXEC VectorizeText @QueryText, @Vector OUTPUT

  SELECT p.Name, pd.Description, vs.Distance
  FROM VECTOR_SEARCH(
    TABLE = Production.ProductVector AS pv,
    COLUMN = ProductVector,
    SIMILAR_TO = @Vector,
    METRIC = 'cosine',
    TOP_N = @Top
  ) AS vs
  JOIN Production.ProductVector pv2 ON vs.ProductVectorID = pv2.ProductVectorID
  JOIN Production.Product p ON pv2.ProductID = p.ProductID
  JOIN Production.ProductDescription pd ON pv2.ProductDescriptionID = pd.ProductDescriptionID
  ORDER BY vs.Distance
END
```

This approach is significantly faster than KNN search, especially at scale, and returns results with high—but not guaranteed—accuracy.

---

## Defining and Using an External AI Model

For production use, you should avoid hard-coding REST calls. Instead, you can define an external model and let SQL Server handle the call securely and natively.

```sql
CREATE EXTERNAL MODEL ProductTextEmbeddingModel
AUTHORIZATION AIRole
WITH (
  LOCATION = 'https://lenni-openai.openai.azure.com/openai/deployments/lenni-text-embedding-ada-002/embeddings?api-version=2023-03-15-preview',
  API_FORMAT = 'Azure OpenAI',
  MODEL_TYPE = EMBEDDINGS,
  MODEL = 'lenni-text-embedding-ada-002',
  CREDENTIAL = [https://lenni-openai.openai.azure.com]
)
```

Once defined, you can replace the manual embedding logic with a simple statement:

```sql
SELECT @Vector = AI_GENERATE_EMBEDDINGS(@QueryText USE MODEL ProductTextEmbeddingModel)
```

This improves security, simplifies code, and allows fine-grained access control via roles.

---

## Sample Queries

Try these queries to test both search strategies:

```sql
-- KNN search (exact)
EXEC SearchProductsKNN 'Looking for bikes for long-distance rides with storage'

-- ANN search (approximate)
EXEC SearchProductsANN 'Looking for bikes for long-distance rides with storage'
```

You should receive similar results, but the ANN version should be noticeably faster.

---

Let me know if you'd like the entire lab exported to Markdown, Word, or PDF—or if you'd like optional instructor checkpoints and challenge sections added.


___

▶ [Lab: RAG Solution](https://github.com/lennilobel/sql2025-workshop-hol-orlando2025/blob/main/HOL/4.%20AI%20Features/3.%20RAG%20Solution.md)
