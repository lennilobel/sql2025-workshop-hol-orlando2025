# Multiplicative Aggregates with the PRODUCT Function

This lab explores the new `PRODUCT` function in SQL Server 2025, which calculates the product of a set of numeric values — similar to how `SUM` and `AVG` work for addition and averaging, but for multiplication.

Prior to SQL Server 2025, SQL Server lacked a built-in way to compute the product of values in a set. You had to use workarounds like looping or user-defined aggregates. With `PRODUCT`, this is now a simple one-line expression.

`PRODUCT` supports both aggregate and analytic (windowed) forms and works with both `ALL` values (default) and `DISTINCT` values. Nulls are ignored, and the function is compatible with all numeric types except `bit`.

## Compute Product of Prices for Each Product

This demo illustrates how to use the new `PRODUCT` aggregate function in SQL Server 2025 to calculate the cumulative product of prices for each product across multiple orders. It also shows how to compute the product considering only distinct price values.

```sql
DECLARE @OrderDetail table (
    OrderId int,
    ProductId int,
    Price decimal(10, 4)
)

INSERT INTO @OrderDetail (OrderId, ProductId, Price) VALUES
  (1, 101, 136.87),
  (1, 102, 29.57),
  (1, 103, 396.85),
  (2, 101, 136.87),
  (2, 102, 29.57),
  (3, 101, 136.87),
  (3, 102, 29.57),
  (4, 101, 149.22),
  (4, 102, 29.57)

-- Compute product of all prices and distinct prices for each ProductId
SELECT
    ProductId,
    ProductOfPrices = PRODUCT(Price),
    ProductOfDistinctPrices = PRODUCT(DISTINCT Price)
FROM
    @OrderDetail
GROUP BY
    ProductId
```

### Alternative using `OVER (PARTITION BY ...)`

This version computes the product for each row using a windowed aggregate, allowing you to retain the detail rows while also showing the total product per partition.

```sql
SELECT
    OrderId,
    ProductId,
    Price,
    ProductOfPrices = PRODUCT(Price) OVER (PARTITION BY ProductId),
    ProductOfDistinctPrices = PRODUCT(DISTINCT Price) OVER (PARTITION BY ProductId)
FROM
    @OrderDetail
```

## Compounded Return from Periodic Rates

This demo uses `PRODUCT` to compute the **compounded return** for financial instruments over multiple time periods. It also shows how to compute the return considering only distinct rates to illustrate the difference.

```sql
DECLARE @Instruments table (
    InstrumentId varchar(10),
    Period tinyint,
    RateOfReturn decimal(10, 4)
)

INSERT INTO @Instruments (InstrumentId, Period, RateOfReturn) VALUES
  ('BOND1', 1, 0.0350),
  ('BOND1', 2, 0.0275),
  ('BOND1', 3, 0.0350),    -- duplicate 3.5% return
  ('ETF1',  1, 0.0800),
  ('ETF1',  2, -0.0450),
  ('ETF1',  3, 0.0600),
  ('STOCK1', 1, 0.1250),
  ('STOCK1', 2, 0.0950),
  ('STOCK1', 3, 0.1250)    -- duplicate 12.5% return

-- Compute total and distinct compounded return for each instrument
SELECT
    InstrumentId,
    CompoundedReturn = PRODUCT(1 + RateOfReturn),
    CompoundedDistinctReturn = PRODUCT(DISTINCT 1 + RateOfReturn)
FROM
    @Instruments
GROUP BY
    InstrumentId
```

### Alternative using `OVER (PARTITION BY ...)`

Like the first demo, this version uses window functions to add compounded return to each row.

```sql
SELECT
    InstrumentId,
    Period,
    RateOfReturn,
    CompoundedReturn = PRODUCT(1 + RateOfReturn) OVER (PARTITION BY InstrumentId),
    CompoundedDistinctReturn = PRODUCT(DISTINCT 1 + RateOfReturn) OVER (PARTITION BY InstrumentId)
FROM
    @Instruments
```
